// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/pkg/cart/service.ICartRepository -o cart_repository_mock.go -n ICartRepositoryMock -p mock

import (
	"context"
	"route256/cart/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ICartRepositoryMock implements mm_service.ICartRepository
type ICartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, UID models.UID, item models.CartItem) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(ctx context.Context, UID models.UID, item models.CartItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mICartRepositoryMockAddItem

	funcDeleteItem          func(ctx context.Context, UID models.UID, SKU models.SKU) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(ctx context.Context, UID models.UID, SKU models.SKU)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mICartRepositoryMockDeleteItem

	funcDeleteItemsByUserID          func(ctx context.Context, UID models.UID) (err error)
	funcDeleteItemsByUserIDOrigin    string
	inspectFuncDeleteItemsByUserID   func(ctx context.Context, UID models.UID)
	afterDeleteItemsByUserIDCounter  uint64
	beforeDeleteItemsByUserIDCounter uint64
	DeleteItemsByUserIDMock          mICartRepositoryMockDeleteItemsByUserID

	funcGetItemsByUserID          func(ctx context.Context, UID models.UID) (ca1 []models.CartItem, err error)
	funcGetItemsByUserIDOrigin    string
	inspectFuncGetItemsByUserID   func(ctx context.Context, UID models.UID)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mICartRepositoryMockGetItemsByUserID
}

// NewICartRepositoryMock returns a mock for mm_service.ICartRepository
func NewICartRepositoryMock(t minimock.Tester) *ICartRepositoryMock {
	m := &ICartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mICartRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*ICartRepositoryMockAddItemParams{}

	m.DeleteItemMock = mICartRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*ICartRepositoryMockDeleteItemParams{}

	m.DeleteItemsByUserIDMock = mICartRepositoryMockDeleteItemsByUserID{mock: m}
	m.DeleteItemsByUserIDMock.callArgs = []*ICartRepositoryMockDeleteItemsByUserIDParams{}

	m.GetItemsByUserIDMock = mICartRepositoryMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*ICartRepositoryMockGetItemsByUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mICartRepositoryMockAddItem struct {
	optional           bool
	mock               *ICartRepositoryMock
	defaultExpectation *ICartRepositoryMockAddItemExpectation
	expectations       []*ICartRepositoryMockAddItemExpectation

	callArgs []*ICartRepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepositoryMockAddItemExpectation specifies expectation struct of the ICartRepository.AddItem
type ICartRepositoryMockAddItemExpectation struct {
	mock               *ICartRepositoryMock
	params             *ICartRepositoryMockAddItemParams
	paramPtrs          *ICartRepositoryMockAddItemParamPtrs
	expectationOrigins ICartRepositoryMockAddItemExpectationOrigins
	results            *ICartRepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepositoryMockAddItemParams contains parameters of the ICartRepository.AddItem
type ICartRepositoryMockAddItemParams struct {
	ctx  context.Context
	UID  models.UID
	item models.CartItem
}

// ICartRepositoryMockAddItemParamPtrs contains pointers to parameters of the ICartRepository.AddItem
type ICartRepositoryMockAddItemParamPtrs struct {
	ctx  *context.Context
	UID  *models.UID
	item *models.CartItem
}

// ICartRepositoryMockAddItemResults contains results of the ICartRepository.AddItem
type ICartRepositoryMockAddItemResults struct {
	err error
}

// ICartRepositoryMockAddItemOrigins contains origins of expectations of the ICartRepository.AddItem
type ICartRepositoryMockAddItemExpectationOrigins struct {
	origin     string
	originCtx  string
	originUID  string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mICartRepositoryMockAddItem) Optional() *mICartRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for ICartRepository.AddItem
func (mmAddItem *mICartRepositoryMockAddItem) Expect(ctx context.Context, UID models.UID, item models.CartItem) *mICartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &ICartRepositoryMockAddItemParams{ctx, UID, item}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepository.AddItem
func (mmAddItem *mICartRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mICartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectUIDParam2 sets up expected param UID for ICartRepository.AddItem
func (mmAddItem *mICartRepositoryMockAddItem) ExpectUIDParam2(UID models.UID) *mICartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.UID = &UID
	mmAddItem.defaultExpectation.expectationOrigins.originUID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectItemParam3 sets up expected param item for ICartRepository.AddItem
func (mmAddItem *mICartRepositoryMockAddItem) ExpectItemParam3(item models.CartItem) *mICartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &ICartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item
	mmAddItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the ICartRepository.AddItem
func (mmAddItem *mICartRepositoryMockAddItem) Inspect(f func(ctx context.Context, UID models.UID, item models.CartItem)) *mICartRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for ICartRepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by ICartRepository.AddItem
func (mmAddItem *mICartRepositoryMockAddItem) Return(err error) *ICartRepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &ICartRepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &ICartRepositoryMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the ICartRepository.AddItem method
func (mmAddItem *mICartRepositoryMockAddItem) Set(f func(ctx context.Context, UID models.UID, item models.CartItem) (err error)) *ICartRepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the ICartRepository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the ICartRepository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the ICartRepository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mICartRepositoryMockAddItem) When(ctx context.Context, UID models.UID, item models.CartItem) *ICartRepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("ICartRepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &ICartRepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &ICartRepositoryMockAddItemParams{ctx, UID, item},
		expectationOrigins: ICartRepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up ICartRepository.AddItem return parameters for the expectation previously defined by the When method
func (e *ICartRepositoryMockAddItemExpectation) Then(err error) *ICartRepositoryMock {
	e.results = &ICartRepositoryMockAddItemResults{err}
	return e.mock
}

// Times sets number of times ICartRepository.AddItem should be invoked
func (mmAddItem *mICartRepositoryMockAddItem) Times(n uint64) *mICartRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of ICartRepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mICartRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_service.ICartRepository
func (mmAddItem *ICartRepositoryMock) AddItem(ctx context.Context, UID models.UID, item models.CartItem) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, UID, item)
	}

	mm_params := ICartRepositoryMockAddItemParams{ctx, UID, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := ICartRepositoryMockAddItemParams{ctx, UID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("ICartRepositoryMock.AddItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.UID != nil && !minimock.Equal(*mm_want_ptrs.UID, mm_got.UID) {
				mmAddItem.t.Errorf("ICartRepositoryMock.AddItem got unexpected parameter UID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originUID, *mm_want_ptrs.UID, mm_got.UID, minimock.Diff(*mm_want_ptrs.UID, mm_got.UID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("ICartRepositoryMock.AddItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("ICartRepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the ICartRepositoryMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, UID, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to ICartRepositoryMock.AddItem. %v %v %v", ctx, UID, item)
	return
}

// AddItemAfterCounter returns a count of finished ICartRepositoryMock.AddItem invocations
func (mmAddItem *ICartRepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of ICartRepositoryMock.AddItem invocations
func (mmAddItem *ICartRepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to ICartRepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mICartRepositoryMockAddItem) Calls() []*ICartRepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*ICartRepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *ICartRepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *ICartRepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to ICartRepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mICartRepositoryMockDeleteItem struct {
	optional           bool
	mock               *ICartRepositoryMock
	defaultExpectation *ICartRepositoryMockDeleteItemExpectation
	expectations       []*ICartRepositoryMockDeleteItemExpectation

	callArgs []*ICartRepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepositoryMockDeleteItemExpectation specifies expectation struct of the ICartRepository.DeleteItem
type ICartRepositoryMockDeleteItemExpectation struct {
	mock               *ICartRepositoryMock
	params             *ICartRepositoryMockDeleteItemParams
	paramPtrs          *ICartRepositoryMockDeleteItemParamPtrs
	expectationOrigins ICartRepositoryMockDeleteItemExpectationOrigins
	results            *ICartRepositoryMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepositoryMockDeleteItemParams contains parameters of the ICartRepository.DeleteItem
type ICartRepositoryMockDeleteItemParams struct {
	ctx context.Context
	UID models.UID
	SKU models.SKU
}

// ICartRepositoryMockDeleteItemParamPtrs contains pointers to parameters of the ICartRepository.DeleteItem
type ICartRepositoryMockDeleteItemParamPtrs struct {
	ctx *context.Context
	UID *models.UID
	SKU *models.SKU
}

// ICartRepositoryMockDeleteItemResults contains results of the ICartRepository.DeleteItem
type ICartRepositoryMockDeleteItemResults struct {
	err error
}

// ICartRepositoryMockDeleteItemOrigins contains origins of expectations of the ICartRepository.DeleteItem
type ICartRepositoryMockDeleteItemExpectationOrigins struct {
	origin    string
	originCtx string
	originUID string
	originSKU string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Optional() *mICartRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for ICartRepository.DeleteItem
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Expect(ctx context.Context, UID models.UID, SKU models.SKU) *mICartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &ICartRepositoryMockDeleteItemParams{ctx, UID, SKU}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepository.DeleteItem
func (mmDeleteItem *mICartRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mICartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectUIDParam2 sets up expected param UID for ICartRepository.DeleteItem
func (mmDeleteItem *mICartRepositoryMockDeleteItem) ExpectUIDParam2(UID models.UID) *mICartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.UID = &UID
	mmDeleteItem.defaultExpectation.expectationOrigins.originUID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectSKUParam3 sets up expected param SKU for ICartRepository.DeleteItem
func (mmDeleteItem *mICartRepositoryMockDeleteItem) ExpectSKUParam3(SKU models.SKU) *mICartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &ICartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.SKU = &SKU
	mmDeleteItem.defaultExpectation.expectationOrigins.originSKU = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the ICartRepository.DeleteItem
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, UID models.UID, SKU models.SKU)) *mICartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for ICartRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by ICartRepository.DeleteItem
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Return(err error) *ICartRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &ICartRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &ICartRepositoryMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the ICartRepository.DeleteItem method
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Set(f func(ctx context.Context, UID models.UID, SKU models.SKU) (err error)) *ICartRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the ICartRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the ICartRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the ICartRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mICartRepositoryMockDeleteItem) When(ctx context.Context, UID models.UID, SKU models.SKU) *ICartRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("ICartRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &ICartRepositoryMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &ICartRepositoryMockDeleteItemParams{ctx, UID, SKU},
		expectationOrigins: ICartRepositoryMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up ICartRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *ICartRepositoryMockDeleteItemExpectation) Then(err error) *ICartRepositoryMock {
	e.results = &ICartRepositoryMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times ICartRepository.DeleteItem should be invoked
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Times(n uint64) *mICartRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of ICartRepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mICartRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_service.ICartRepository
func (mmDeleteItem *ICartRepositoryMock) DeleteItem(ctx context.Context, UID models.UID, SKU models.SKU) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, UID, SKU)
	}

	mm_params := ICartRepositoryMockDeleteItemParams{ctx, UID, SKU}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := ICartRepositoryMockDeleteItemParams{ctx, UID, SKU}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("ICartRepositoryMock.DeleteItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.UID != nil && !minimock.Equal(*mm_want_ptrs.UID, mm_got.UID) {
				mmDeleteItem.t.Errorf("ICartRepositoryMock.DeleteItem got unexpected parameter UID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUID, *mm_want_ptrs.UID, mm_got.UID, minimock.Diff(*mm_want_ptrs.UID, mm_got.UID))
			}

			if mm_want_ptrs.SKU != nil && !minimock.Equal(*mm_want_ptrs.SKU, mm_got.SKU) {
				mmDeleteItem.t.Errorf("ICartRepositoryMock.DeleteItem got unexpected parameter SKU, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originSKU, *mm_want_ptrs.SKU, mm_got.SKU, minimock.Diff(*mm_want_ptrs.SKU, mm_got.SKU))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("ICartRepositoryMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the ICartRepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, UID, SKU)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to ICartRepositoryMock.DeleteItem. %v %v %v", ctx, UID, SKU)
	return
}

// DeleteItemAfterCounter returns a count of finished ICartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *ICartRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of ICartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *ICartRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to ICartRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mICartRepositoryMockDeleteItem) Calls() []*ICartRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*ICartRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *ICartRepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *ICartRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepositoryMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mICartRepositoryMockDeleteItemsByUserID struct {
	optional           bool
	mock               *ICartRepositoryMock
	defaultExpectation *ICartRepositoryMockDeleteItemsByUserIDExpectation
	expectations       []*ICartRepositoryMockDeleteItemsByUserIDExpectation

	callArgs []*ICartRepositoryMockDeleteItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepositoryMockDeleteItemsByUserIDExpectation specifies expectation struct of the ICartRepository.DeleteItemsByUserID
type ICartRepositoryMockDeleteItemsByUserIDExpectation struct {
	mock               *ICartRepositoryMock
	params             *ICartRepositoryMockDeleteItemsByUserIDParams
	paramPtrs          *ICartRepositoryMockDeleteItemsByUserIDParamPtrs
	expectationOrigins ICartRepositoryMockDeleteItemsByUserIDExpectationOrigins
	results            *ICartRepositoryMockDeleteItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepositoryMockDeleteItemsByUserIDParams contains parameters of the ICartRepository.DeleteItemsByUserID
type ICartRepositoryMockDeleteItemsByUserIDParams struct {
	ctx context.Context
	UID models.UID
}

// ICartRepositoryMockDeleteItemsByUserIDParamPtrs contains pointers to parameters of the ICartRepository.DeleteItemsByUserID
type ICartRepositoryMockDeleteItemsByUserIDParamPtrs struct {
	ctx *context.Context
	UID *models.UID
}

// ICartRepositoryMockDeleteItemsByUserIDResults contains results of the ICartRepository.DeleteItemsByUserID
type ICartRepositoryMockDeleteItemsByUserIDResults struct {
	err error
}

// ICartRepositoryMockDeleteItemsByUserIDOrigins contains origins of expectations of the ICartRepository.DeleteItemsByUserID
type ICartRepositoryMockDeleteItemsByUserIDExpectationOrigins struct {
	origin    string
	originCtx string
	originUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Optional() *mICartRepositoryMockDeleteItemsByUserID {
	mmDeleteItemsByUserID.optional = true
	return mmDeleteItemsByUserID
}

// Expect sets up expected params for ICartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Expect(ctx context.Context, UID models.UID) *mICartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ICartRepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by ExpectParams functions")
	}

	mmDeleteItemsByUserID.defaultExpectation.params = &ICartRepositoryMockDeleteItemsByUserIDParams{ctx, UID}
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItemsByUserID.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUserID.defaultExpectation.params) {
			mmDeleteItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUserID.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) ExpectCtxParam1(ctx context.Context) *mICartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ICartRepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &ICartRepositoryMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteItemsByUserID
}

// ExpectUIDParam2 sets up expected param UID for ICartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) ExpectUIDParam2(UID models.UID) *mICartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ICartRepositoryMockDeleteItemsByUserIDExpectation{}
	}

	if mmDeleteItemsByUserID.defaultExpectation.params != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmDeleteItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUserID.defaultExpectation.paramPtrs = &ICartRepositoryMockDeleteItemsByUserIDParamPtrs{}
	}
	mmDeleteItemsByUserID.defaultExpectation.paramPtrs.UID = &UID
	mmDeleteItemsByUserID.defaultExpectation.expectationOrigins.originUID = minimock.CallerInfo(1)

	return mmDeleteItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Inspect(f func(ctx context.Context, UID models.UID)) *mICartRepositoryMockDeleteItemsByUserID {
	if mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Inspect function is already set for ICartRepositoryMock.DeleteItemsByUserID")
	}

	mmDeleteItemsByUserID.mock.inspectFuncDeleteItemsByUserID = f

	return mmDeleteItemsByUserID
}

// Return sets up results that will be returned by ICartRepository.DeleteItemsByUserID
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Return(err error) *ICartRepositoryMock {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmDeleteItemsByUserID.defaultExpectation == nil {
		mmDeleteItemsByUserID.defaultExpectation = &ICartRepositoryMockDeleteItemsByUserIDExpectation{mock: mmDeleteItemsByUserID.mock}
	}
	mmDeleteItemsByUserID.defaultExpectation.results = &ICartRepositoryMockDeleteItemsByUserIDResults{err}
	mmDeleteItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID.mock
}

// Set uses given function f to mock the ICartRepository.DeleteItemsByUserID method
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Set(f func(ctx context.Context, UID models.UID) (err error)) *ICartRepositoryMock {
	if mmDeleteItemsByUserID.defaultExpectation != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("Default expectation is already set for the ICartRepository.DeleteItemsByUserID method")
	}

	if len(mmDeleteItemsByUserID.expectations) > 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Some expectations are already set for the ICartRepository.DeleteItemsByUserID method")
	}

	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID = f
	mmDeleteItemsByUserID.mock.funcDeleteItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID.mock
}

// When sets expectation for the ICartRepository.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) When(ctx context.Context, UID models.UID) *ICartRepositoryMockDeleteItemsByUserIDExpectation {
	if mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &ICartRepositoryMockDeleteItemsByUserIDExpectation{
		mock:               mmDeleteItemsByUserID.mock,
		params:             &ICartRepositoryMockDeleteItemsByUserIDParams{ctx, UID},
		expectationOrigins: ICartRepositoryMockDeleteItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItemsByUserID.expectations = append(mmDeleteItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartRepository.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *ICartRepositoryMockDeleteItemsByUserIDExpectation) Then(err error) *ICartRepositoryMock {
	e.results = &ICartRepositoryMockDeleteItemsByUserIDResults{err}
	return e.mock
}

// Times sets number of times ICartRepository.DeleteItemsByUserID should be invoked
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Times(n uint64) *mICartRepositoryMockDeleteItemsByUserID {
	if n == 0 {
		mmDeleteItemsByUserID.mock.t.Fatalf("Times of ICartRepositoryMock.DeleteItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsByUserID.expectedInvocations, n)
	mmDeleteItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUserID
}

func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) invocationsDone() bool {
	if len(mmDeleteItemsByUserID.expectations) == 0 && mmDeleteItemsByUserID.defaultExpectation == nil && mmDeleteItemsByUserID.mock.funcDeleteItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.mock.afterDeleteItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsByUserID implements mm_service.ICartRepository
func (mmDeleteItemsByUserID *ICartRepositoryMock) DeleteItemsByUserID(ctx context.Context, UID models.UID) (err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter, 1)

	mmDeleteItemsByUserID.t.Helper()

	if mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID != nil {
		mmDeleteItemsByUserID.inspectFuncDeleteItemsByUserID(ctx, UID)
	}

	mm_params := ICartRepositoryMockDeleteItemsByUserIDParams{ctx, UID}

	// Record call args
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Lock()
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs = append(mmDeleteItemsByUserID.DeleteItemsByUserIDMock.callArgs, &mm_params)
	mmDeleteItemsByUserID.DeleteItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUserID.DeleteItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartRepositoryMockDeleteItemsByUserIDParams{ctx, UID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItemsByUserID.t.Errorf("ICartRepositoryMock.DeleteItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.UID != nil && !minimock.Equal(*mm_want_ptrs.UID, mm_got.UID) {
				mmDeleteItemsByUserID.t.Errorf("ICartRepositoryMock.DeleteItemsByUserID got unexpected parameter UID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.originUID, *mm_want_ptrs.UID, mm_got.UID, minimock.Diff(*mm_want_ptrs.UID, mm_got.UID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUserID.t.Errorf("ICartRepositoryMock.DeleteItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUserID.DeleteItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUserID.t.Fatal("No results are set for the ICartRepositoryMock.DeleteItemsByUserID")
		}
		return (*mm_results).err
	}
	if mmDeleteItemsByUserID.funcDeleteItemsByUserID != nil {
		return mmDeleteItemsByUserID.funcDeleteItemsByUserID(ctx, UID)
	}
	mmDeleteItemsByUserID.t.Fatalf("Unexpected call to ICartRepositoryMock.DeleteItemsByUserID. %v %v", ctx, UID)
	return
}

// DeleteItemsByUserIDAfterCounter returns a count of finished ICartRepositoryMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *ICartRepositoryMock) DeleteItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.afterDeleteItemsByUserIDCounter)
}

// DeleteItemsByUserIDBeforeCounter returns a count of ICartRepositoryMock.DeleteItemsByUserID invocations
func (mmDeleteItemsByUserID *ICartRepositoryMock) DeleteItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUserID.beforeDeleteItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartRepositoryMock.DeleteItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUserID *mICartRepositoryMockDeleteItemsByUserID) Calls() []*ICartRepositoryMockDeleteItemsByUserIDParams {
	mmDeleteItemsByUserID.mutex.RLock()

	argCopy := make([]*ICartRepositoryMockDeleteItemsByUserIDParams, len(mmDeleteItemsByUserID.callArgs))
	copy(argCopy, mmDeleteItemsByUserID.callArgs)

	mmDeleteItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserIDDone returns true if the count of the DeleteItemsByUserID invocations corresponds
// the number of defined expectations
func (m *ICartRepositoryMock) MinimockDeleteItemsByUserIDDone() bool {
	if m.DeleteItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsByUserIDMock.invocationsDone()
}

// MinimockDeleteItemsByUserIDInspect logs each unmet expectation
func (m *ICartRepositoryMock) MinimockDeleteItemsByUserIDInspect() {
	for _, e := range m.DeleteItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserIDMock.defaultExpectation != nil && afterDeleteItemsByUserIDCounter < 1 {
		if m.DeleteItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItemsByUserID at\n%s", m.DeleteItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItemsByUserID at\n%s with params: %#v", m.DeleteItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUserID != nil && afterDeleteItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartRepositoryMock.DeleteItemsByUserID at\n%s", m.funcDeleteItemsByUserIDOrigin)
	}

	if !m.DeleteItemsByUserIDMock.invocationsDone() && afterDeleteItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepositoryMock.DeleteItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsByUserIDMock.expectedInvocations), m.DeleteItemsByUserIDMock.expectedInvocationsOrigin, afterDeleteItemsByUserIDCounter)
	}
}

type mICartRepositoryMockGetItemsByUserID struct {
	optional           bool
	mock               *ICartRepositoryMock
	defaultExpectation *ICartRepositoryMockGetItemsByUserIDExpectation
	expectations       []*ICartRepositoryMockGetItemsByUserIDExpectation

	callArgs []*ICartRepositoryMockGetItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ICartRepositoryMockGetItemsByUserIDExpectation specifies expectation struct of the ICartRepository.GetItemsByUserID
type ICartRepositoryMockGetItemsByUserIDExpectation struct {
	mock               *ICartRepositoryMock
	params             *ICartRepositoryMockGetItemsByUserIDParams
	paramPtrs          *ICartRepositoryMockGetItemsByUserIDParamPtrs
	expectationOrigins ICartRepositoryMockGetItemsByUserIDExpectationOrigins
	results            *ICartRepositoryMockGetItemsByUserIDResults
	returnOrigin       string
	Counter            uint64
}

// ICartRepositoryMockGetItemsByUserIDParams contains parameters of the ICartRepository.GetItemsByUserID
type ICartRepositoryMockGetItemsByUserIDParams struct {
	ctx context.Context
	UID models.UID
}

// ICartRepositoryMockGetItemsByUserIDParamPtrs contains pointers to parameters of the ICartRepository.GetItemsByUserID
type ICartRepositoryMockGetItemsByUserIDParamPtrs struct {
	ctx *context.Context
	UID *models.UID
}

// ICartRepositoryMockGetItemsByUserIDResults contains results of the ICartRepository.GetItemsByUserID
type ICartRepositoryMockGetItemsByUserIDResults struct {
	ca1 []models.CartItem
	err error
}

// ICartRepositoryMockGetItemsByUserIDOrigins contains origins of expectations of the ICartRepository.GetItemsByUserID
type ICartRepositoryMockGetItemsByUserIDExpectationOrigins struct {
	origin    string
	originCtx string
	originUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Optional() *mICartRepositoryMockGetItemsByUserID {
	mmGetItemsByUserID.optional = true
	return mmGetItemsByUserID
}

// Expect sets up expected params for ICartRepository.GetItemsByUserID
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Expect(ctx context.Context, UID models.UID) *mICartRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartRepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by ExpectParams functions")
	}

	mmGetItemsByUserID.defaultExpectation.params = &ICartRepositoryMockGetItemsByUserIDParams{ctx, UID}
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for ICartRepository.GetItemsByUserID
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) ExpectCtxParam1(ctx context.Context) *mICartRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartRepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &ICartRepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// ExpectUIDParam2 sets up expected param UID for ICartRepository.GetItemsByUserID
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) ExpectUIDParam2(UID models.UID) *mICartRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartRepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &ICartRepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.UID = &UID
	mmGetItemsByUserID.defaultExpectation.expectationOrigins.originUID = minimock.CallerInfo(1)

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the ICartRepository.GetItemsByUserID
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Inspect(f func(ctx context.Context, UID models.UID)) *mICartRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for ICartRepositoryMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by ICartRepository.GetItemsByUserID
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Return(ca1 []models.CartItem, err error) *ICartRepositoryMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &ICartRepositoryMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &ICartRepositoryMockGetItemsByUserIDResults{ca1, err}
	mmGetItemsByUserID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the ICartRepository.GetItemsByUserID method
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Set(f func(ctx context.Context, UID models.UID) (ca1 []models.CartItem, err error)) *ICartRepositoryMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the ICartRepository.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the ICartRepository.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	mmGetItemsByUserID.mock.funcGetItemsByUserIDOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID.mock
}

// When sets expectation for the ICartRepository.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) When(ctx context.Context, UID models.UID) *ICartRepositoryMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("ICartRepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &ICartRepositoryMockGetItemsByUserIDExpectation{
		mock:               mmGetItemsByUserID.mock,
		params:             &ICartRepositoryMockGetItemsByUserIDParams{ctx, UID},
		expectationOrigins: ICartRepositoryMockGetItemsByUserIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up ICartRepository.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *ICartRepositoryMockGetItemsByUserIDExpectation) Then(ca1 []models.CartItem, err error) *ICartRepositoryMock {
	e.results = &ICartRepositoryMockGetItemsByUserIDResults{ca1, err}
	return e.mock
}

// Times sets number of times ICartRepository.GetItemsByUserID should be invoked
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Times(n uint64) *mICartRepositoryMockGetItemsByUserID {
	if n == 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Times of ICartRepositoryMock.GetItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByUserID.expectedInvocations, n)
	mmGetItemsByUserID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUserID
}

func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) invocationsDone() bool {
	if len(mmGetItemsByUserID.expectations) == 0 && mmGetItemsByUserID.defaultExpectation == nil && mmGetItemsByUserID.mock.funcGetItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.mock.afterGetItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByUserID implements mm_service.ICartRepository
func (mmGetItemsByUserID *ICartRepositoryMock) GetItemsByUserID(ctx context.Context, UID models.UID) (ca1 []models.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	mmGetItemsByUserID.t.Helper()

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, UID)
	}

	mm_params := ICartRepositoryMockGetItemsByUserIDParams{ctx, UID}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, &mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := ICartRepositoryMockGetItemsByUserIDParams{ctx, UID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsByUserID.t.Errorf("ICartRepositoryMock.GetItemsByUserID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.UID != nil && !minimock.Equal(*mm_want_ptrs.UID, mm_got.UID) {
				mmGetItemsByUserID.t.Errorf("ICartRepositoryMock.GetItemsByUserID got unexpected parameter UID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.originUID, *mm_want_ptrs.UID, mm_got.UID, minimock.Diff(*mm_want_ptrs.UID, mm_got.UID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("ICartRepositoryMock.GetItemsByUserID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the ICartRepositoryMock.GetItemsByUserID")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, UID)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to ICartRepositoryMock.GetItemsByUserID. %v %v", ctx, UID)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished ICartRepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *ICartRepositoryMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of ICartRepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *ICartRepositoryMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to ICartRepositoryMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mICartRepositoryMockGetItemsByUserID) Calls() []*ICartRepositoryMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*ICartRepositoryMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *ICartRepositoryMock) MinimockGetItemsByUserIDDone() bool {
	if m.GetItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByUserIDMock.invocationsDone()
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *ICartRepositoryMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ICartRepositoryMock.GetItemsByUserID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && afterGetItemsByUserIDCounter < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ICartRepositoryMock.GetItemsByUserID at\n%s", m.GetItemsByUserIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ICartRepositoryMock.GetItemsByUserID at\n%s with params: %#v", m.GetItemsByUserIDMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && afterGetItemsByUserIDCounter < 1 {
		m.t.Errorf("Expected call to ICartRepositoryMock.GetItemsByUserID at\n%s", m.funcGetItemsByUserIDOrigin)
	}

	if !m.GetItemsByUserIDMock.invocationsDone() && afterGetItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ICartRepositoryMock.GetItemsByUserID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByUserIDMock.expectedInvocations), m.GetItemsByUserIDMock.expectedInvocationsOrigin, afterGetItemsByUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ICartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsByUserIDInspect()

			m.MinimockGetItemsByUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ICartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ICartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserIDDone() &&
		m.MinimockGetItemsByUserIDDone()
}
