// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.IOutboxRepository -o outbox_repository_mock.go -n IOutboxRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// IOutboxRepositoryMock implements mm_service.IOutboxRepository
type IOutboxRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateEvent          func(ctx context.Context, tx pgx.Tx, eventType string, payload interface{}) (err error)
	funcCreateEventOrigin    string
	inspectFuncCreateEvent   func(ctx context.Context, tx pgx.Tx, eventType string, payload interface{})
	afterCreateEventCounter  uint64
	beforeCreateEventCounter uint64
	CreateEventMock          mIOutboxRepositoryMockCreateEvent

	funcFetchNextMsg          func(ctx context.Context, tx pgx.Tx) (op1 *models.OutboxEvent, err error)
	funcFetchNextMsgOrigin    string
	inspectFuncFetchNextMsg   func(ctx context.Context, tx pgx.Tx)
	afterFetchNextMsgCounter  uint64
	beforeFetchNextMsgCounter uint64
	FetchNextMsgMock          mIOutboxRepositoryMockFetchNextMsg

	funcMarkAsSent          func(ctx context.Context, tx pgx.Tx, eventID int64) (err error)
	funcMarkAsSentOrigin    string
	inspectFuncMarkAsSent   func(ctx context.Context, tx pgx.Tx, eventID int64)
	afterMarkAsSentCounter  uint64
	beforeMarkAsSentCounter uint64
	MarkAsSentMock          mIOutboxRepositoryMockMarkAsSent
}

// NewIOutboxRepositoryMock returns a mock for mm_service.IOutboxRepository
func NewIOutboxRepositoryMock(t minimock.Tester) *IOutboxRepositoryMock {
	m := &IOutboxRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateEventMock = mIOutboxRepositoryMockCreateEvent{mock: m}
	m.CreateEventMock.callArgs = []*IOutboxRepositoryMockCreateEventParams{}

	m.FetchNextMsgMock = mIOutboxRepositoryMockFetchNextMsg{mock: m}
	m.FetchNextMsgMock.callArgs = []*IOutboxRepositoryMockFetchNextMsgParams{}

	m.MarkAsSentMock = mIOutboxRepositoryMockMarkAsSent{mock: m}
	m.MarkAsSentMock.callArgs = []*IOutboxRepositoryMockMarkAsSentParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIOutboxRepositoryMockCreateEvent struct {
	optional           bool
	mock               *IOutboxRepositoryMock
	defaultExpectation *IOutboxRepositoryMockCreateEventExpectation
	expectations       []*IOutboxRepositoryMockCreateEventExpectation

	callArgs []*IOutboxRepositoryMockCreateEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOutboxRepositoryMockCreateEventExpectation specifies expectation struct of the IOutboxRepository.CreateEvent
type IOutboxRepositoryMockCreateEventExpectation struct {
	mock               *IOutboxRepositoryMock
	params             *IOutboxRepositoryMockCreateEventParams
	paramPtrs          *IOutboxRepositoryMockCreateEventParamPtrs
	expectationOrigins IOutboxRepositoryMockCreateEventExpectationOrigins
	results            *IOutboxRepositoryMockCreateEventResults
	returnOrigin       string
	Counter            uint64
}

// IOutboxRepositoryMockCreateEventParams contains parameters of the IOutboxRepository.CreateEvent
type IOutboxRepositoryMockCreateEventParams struct {
	ctx       context.Context
	tx        pgx.Tx
	eventType string
	payload   interface{}
}

// IOutboxRepositoryMockCreateEventParamPtrs contains pointers to parameters of the IOutboxRepository.CreateEvent
type IOutboxRepositoryMockCreateEventParamPtrs struct {
	ctx       *context.Context
	tx        *pgx.Tx
	eventType *string
	payload   *interface{}
}

// IOutboxRepositoryMockCreateEventResults contains results of the IOutboxRepository.CreateEvent
type IOutboxRepositoryMockCreateEventResults struct {
	err error
}

// IOutboxRepositoryMockCreateEventOrigins contains origins of expectations of the IOutboxRepository.CreateEvent
type IOutboxRepositoryMockCreateEventExpectationOrigins struct {
	origin          string
	originCtx       string
	originTx        string
	originEventType string
	originPayload   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Optional() *mIOutboxRepositoryMockCreateEvent {
	mmCreateEvent.optional = true
	return mmCreateEvent
}

// Expect sets up expected params for IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Expect(ctx context.Context, tx pgx.Tx, eventType string, payload interface{}) *mIOutboxRepositoryMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &IOutboxRepositoryMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.paramPtrs != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by ExpectParams functions")
	}

	mmCreateEvent.defaultExpectation.params = &IOutboxRepositoryMockCreateEventParams{ctx, tx, eventType, payload}
	mmCreateEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateEvent.expectations {
		if minimock.Equal(e.params, mmCreateEvent.defaultExpectation.params) {
			mmCreateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEvent.defaultExpectation.params)
		}
	}

	return mmCreateEvent
}

// ExpectCtxParam1 sets up expected param ctx for IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) ExpectCtxParam1(ctx context.Context) *mIOutboxRepositoryMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &IOutboxRepositoryMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateEvent
}

// ExpectTxParam2 sets up expected param tx for IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) ExpectTxParam2(tx pgx.Tx) *mIOutboxRepositoryMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &IOutboxRepositoryMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.tx = &tx
	mmCreateEvent.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmCreateEvent
}

// ExpectEventTypeParam3 sets up expected param eventType for IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) ExpectEventTypeParam3(eventType string) *mIOutboxRepositoryMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &IOutboxRepositoryMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.eventType = &eventType
	mmCreateEvent.defaultExpectation.expectationOrigins.originEventType = minimock.CallerInfo(1)

	return mmCreateEvent
}

// ExpectPayloadParam4 sets up expected param payload for IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) ExpectPayloadParam4(payload interface{}) *mIOutboxRepositoryMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &IOutboxRepositoryMockCreateEventExpectation{}
	}

	if mmCreateEvent.defaultExpectation.params != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Expect")
	}

	if mmCreateEvent.defaultExpectation.paramPtrs == nil {
		mmCreateEvent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockCreateEventParamPtrs{}
	}
	mmCreateEvent.defaultExpectation.paramPtrs.payload = &payload
	mmCreateEvent.defaultExpectation.expectationOrigins.originPayload = minimock.CallerInfo(1)

	return mmCreateEvent
}

// Inspect accepts an inspector function that has same arguments as the IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Inspect(f func(ctx context.Context, tx pgx.Tx, eventType string, payload interface{})) *mIOutboxRepositoryMockCreateEvent {
	if mmCreateEvent.mock.inspectFuncCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("Inspect function is already set for IOutboxRepositoryMock.CreateEvent")
	}

	mmCreateEvent.mock.inspectFuncCreateEvent = f

	return mmCreateEvent
}

// Return sets up results that will be returned by IOutboxRepository.CreateEvent
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Return(err error) *IOutboxRepositoryMock {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &IOutboxRepositoryMockCreateEventExpectation{mock: mmCreateEvent.mock}
	}
	mmCreateEvent.defaultExpectation.results = &IOutboxRepositoryMockCreateEventResults{err}
	mmCreateEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateEvent.mock
}

// Set uses given function f to mock the IOutboxRepository.CreateEvent method
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Set(f func(ctx context.Context, tx pgx.Tx, eventType string, payload interface{}) (err error)) *IOutboxRepositoryMock {
	if mmCreateEvent.defaultExpectation != nil {
		mmCreateEvent.mock.t.Fatalf("Default expectation is already set for the IOutboxRepository.CreateEvent method")
	}

	if len(mmCreateEvent.expectations) > 0 {
		mmCreateEvent.mock.t.Fatalf("Some expectations are already set for the IOutboxRepository.CreateEvent method")
	}

	mmCreateEvent.mock.funcCreateEvent = f
	mmCreateEvent.mock.funcCreateEventOrigin = minimock.CallerInfo(1)
	return mmCreateEvent.mock
}

// When sets expectation for the IOutboxRepository.CreateEvent which will trigger the result defined by the following
// Then helper
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) When(ctx context.Context, tx pgx.Tx, eventType string, payload interface{}) *IOutboxRepositoryMockCreateEventExpectation {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("IOutboxRepositoryMock.CreateEvent mock is already set by Set")
	}

	expectation := &IOutboxRepositoryMockCreateEventExpectation{
		mock:               mmCreateEvent.mock,
		params:             &IOutboxRepositoryMockCreateEventParams{ctx, tx, eventType, payload},
		expectationOrigins: IOutboxRepositoryMockCreateEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateEvent.expectations = append(mmCreateEvent.expectations, expectation)
	return expectation
}

// Then sets up IOutboxRepository.CreateEvent return parameters for the expectation previously defined by the When method
func (e *IOutboxRepositoryMockCreateEventExpectation) Then(err error) *IOutboxRepositoryMock {
	e.results = &IOutboxRepositoryMockCreateEventResults{err}
	return e.mock
}

// Times sets number of times IOutboxRepository.CreateEvent should be invoked
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Times(n uint64) *mIOutboxRepositoryMockCreateEvent {
	if n == 0 {
		mmCreateEvent.mock.t.Fatalf("Times of IOutboxRepositoryMock.CreateEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateEvent.expectedInvocations, n)
	mmCreateEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateEvent
}

func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) invocationsDone() bool {
	if len(mmCreateEvent.expectations) == 0 && mmCreateEvent.defaultExpectation == nil && mmCreateEvent.mock.funcCreateEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateEvent.mock.afterCreateEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateEvent implements mm_service.IOutboxRepository
func (mmCreateEvent *IOutboxRepositoryMock) CreateEvent(ctx context.Context, tx pgx.Tx, eventType string, payload interface{}) (err error) {
	mm_atomic.AddUint64(&mmCreateEvent.beforeCreateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEvent.afterCreateEventCounter, 1)

	mmCreateEvent.t.Helper()

	if mmCreateEvent.inspectFuncCreateEvent != nil {
		mmCreateEvent.inspectFuncCreateEvent(ctx, tx, eventType, payload)
	}

	mm_params := IOutboxRepositoryMockCreateEventParams{ctx, tx, eventType, payload}

	// Record call args
	mmCreateEvent.CreateEventMock.mutex.Lock()
	mmCreateEvent.CreateEventMock.callArgs = append(mmCreateEvent.CreateEventMock.callArgs, &mm_params)
	mmCreateEvent.CreateEventMock.mutex.Unlock()

	for _, e := range mmCreateEvent.CreateEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateEvent.CreateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEvent.CreateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEvent.CreateEventMock.defaultExpectation.params
		mm_want_ptrs := mmCreateEvent.CreateEventMock.defaultExpectation.paramPtrs

		mm_got := IOutboxRepositoryMockCreateEventParams{ctx, tx, eventType, payload}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateEvent.t.Errorf("IOutboxRepositoryMock.CreateEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmCreateEvent.t.Errorf("IOutboxRepositoryMock.CreateEvent got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.eventType != nil && !minimock.Equal(*mm_want_ptrs.eventType, mm_got.eventType) {
				mmCreateEvent.t.Errorf("IOutboxRepositoryMock.CreateEvent got unexpected parameter eventType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originEventType, *mm_want_ptrs.eventType, mm_got.eventType, minimock.Diff(*mm_want_ptrs.eventType, mm_got.eventType))
			}

			if mm_want_ptrs.payload != nil && !minimock.Equal(*mm_want_ptrs.payload, mm_got.payload) {
				mmCreateEvent.t.Errorf("IOutboxRepositoryMock.CreateEvent got unexpected parameter payload, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.originPayload, *mm_want_ptrs.payload, mm_got.payload, minimock.Diff(*mm_want_ptrs.payload, mm_got.payload))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEvent.t.Errorf("IOutboxRepositoryMock.CreateEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateEvent.CreateEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEvent.CreateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEvent.t.Fatal("No results are set for the IOutboxRepositoryMock.CreateEvent")
		}
		return (*mm_results).err
	}
	if mmCreateEvent.funcCreateEvent != nil {
		return mmCreateEvent.funcCreateEvent(ctx, tx, eventType, payload)
	}
	mmCreateEvent.t.Fatalf("Unexpected call to IOutboxRepositoryMock.CreateEvent. %v %v %v %v", ctx, tx, eventType, payload)
	return
}

// CreateEventAfterCounter returns a count of finished IOutboxRepositoryMock.CreateEvent invocations
func (mmCreateEvent *IOutboxRepositoryMock) CreateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.afterCreateEventCounter)
}

// CreateEventBeforeCounter returns a count of IOutboxRepositoryMock.CreateEvent invocations
func (mmCreateEvent *IOutboxRepositoryMock) CreateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.beforeCreateEventCounter)
}

// Calls returns a list of arguments used in each call to IOutboxRepositoryMock.CreateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEvent *mIOutboxRepositoryMockCreateEvent) Calls() []*IOutboxRepositoryMockCreateEventParams {
	mmCreateEvent.mutex.RLock()

	argCopy := make([]*IOutboxRepositoryMockCreateEventParams, len(mmCreateEvent.callArgs))
	copy(argCopy, mmCreateEvent.callArgs)

	mmCreateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEventDone returns true if the count of the CreateEvent invocations corresponds
// the number of defined expectations
func (m *IOutboxRepositoryMock) MinimockCreateEventDone() bool {
	if m.CreateEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateEventMock.invocationsDone()
}

// MinimockCreateEventInspect logs each unmet expectation
func (m *IOutboxRepositoryMock) MinimockCreateEventInspect() {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.CreateEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateEventCounter := mm_atomic.LoadUint64(&m.afterCreateEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && afterCreateEventCounter < 1 {
		if m.CreateEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.CreateEvent at\n%s", m.CreateEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.CreateEvent at\n%s with params: %#v", m.CreateEventMock.defaultExpectation.expectationOrigins.origin, *m.CreateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && afterCreateEventCounter < 1 {
		m.t.Errorf("Expected call to IOutboxRepositoryMock.CreateEvent at\n%s", m.funcCreateEventOrigin)
	}

	if !m.CreateEventMock.invocationsDone() && afterCreateEventCounter > 0 {
		m.t.Errorf("Expected %d calls to IOutboxRepositoryMock.CreateEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateEventMock.expectedInvocations), m.CreateEventMock.expectedInvocationsOrigin, afterCreateEventCounter)
	}
}

type mIOutboxRepositoryMockFetchNextMsg struct {
	optional           bool
	mock               *IOutboxRepositoryMock
	defaultExpectation *IOutboxRepositoryMockFetchNextMsgExpectation
	expectations       []*IOutboxRepositoryMockFetchNextMsgExpectation

	callArgs []*IOutboxRepositoryMockFetchNextMsgParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOutboxRepositoryMockFetchNextMsgExpectation specifies expectation struct of the IOutboxRepository.FetchNextMsg
type IOutboxRepositoryMockFetchNextMsgExpectation struct {
	mock               *IOutboxRepositoryMock
	params             *IOutboxRepositoryMockFetchNextMsgParams
	paramPtrs          *IOutboxRepositoryMockFetchNextMsgParamPtrs
	expectationOrigins IOutboxRepositoryMockFetchNextMsgExpectationOrigins
	results            *IOutboxRepositoryMockFetchNextMsgResults
	returnOrigin       string
	Counter            uint64
}

// IOutboxRepositoryMockFetchNextMsgParams contains parameters of the IOutboxRepository.FetchNextMsg
type IOutboxRepositoryMockFetchNextMsgParams struct {
	ctx context.Context
	tx  pgx.Tx
}

// IOutboxRepositoryMockFetchNextMsgParamPtrs contains pointers to parameters of the IOutboxRepository.FetchNextMsg
type IOutboxRepositoryMockFetchNextMsgParamPtrs struct {
	ctx *context.Context
	tx  *pgx.Tx
}

// IOutboxRepositoryMockFetchNextMsgResults contains results of the IOutboxRepository.FetchNextMsg
type IOutboxRepositoryMockFetchNextMsgResults struct {
	op1 *models.OutboxEvent
	err error
}

// IOutboxRepositoryMockFetchNextMsgOrigins contains origins of expectations of the IOutboxRepository.FetchNextMsg
type IOutboxRepositoryMockFetchNextMsgExpectationOrigins struct {
	origin    string
	originCtx string
	originTx  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Optional() *mIOutboxRepositoryMockFetchNextMsg {
	mmFetchNextMsg.optional = true
	return mmFetchNextMsg
}

// Expect sets up expected params for IOutboxRepository.FetchNextMsg
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Expect(ctx context.Context, tx pgx.Tx) *mIOutboxRepositoryMockFetchNextMsg {
	if mmFetchNextMsg.mock.funcFetchNextMsg != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Set")
	}

	if mmFetchNextMsg.defaultExpectation == nil {
		mmFetchNextMsg.defaultExpectation = &IOutboxRepositoryMockFetchNextMsgExpectation{}
	}

	if mmFetchNextMsg.defaultExpectation.paramPtrs != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by ExpectParams functions")
	}

	mmFetchNextMsg.defaultExpectation.params = &IOutboxRepositoryMockFetchNextMsgParams{ctx, tx}
	mmFetchNextMsg.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFetchNextMsg.expectations {
		if minimock.Equal(e.params, mmFetchNextMsg.defaultExpectation.params) {
			mmFetchNextMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFetchNextMsg.defaultExpectation.params)
		}
	}

	return mmFetchNextMsg
}

// ExpectCtxParam1 sets up expected param ctx for IOutboxRepository.FetchNextMsg
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) ExpectCtxParam1(ctx context.Context) *mIOutboxRepositoryMockFetchNextMsg {
	if mmFetchNextMsg.mock.funcFetchNextMsg != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Set")
	}

	if mmFetchNextMsg.defaultExpectation == nil {
		mmFetchNextMsg.defaultExpectation = &IOutboxRepositoryMockFetchNextMsgExpectation{}
	}

	if mmFetchNextMsg.defaultExpectation.params != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Expect")
	}

	if mmFetchNextMsg.defaultExpectation.paramPtrs == nil {
		mmFetchNextMsg.defaultExpectation.paramPtrs = &IOutboxRepositoryMockFetchNextMsgParamPtrs{}
	}
	mmFetchNextMsg.defaultExpectation.paramPtrs.ctx = &ctx
	mmFetchNextMsg.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFetchNextMsg
}

// ExpectTxParam2 sets up expected param tx for IOutboxRepository.FetchNextMsg
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) ExpectTxParam2(tx pgx.Tx) *mIOutboxRepositoryMockFetchNextMsg {
	if mmFetchNextMsg.mock.funcFetchNextMsg != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Set")
	}

	if mmFetchNextMsg.defaultExpectation == nil {
		mmFetchNextMsg.defaultExpectation = &IOutboxRepositoryMockFetchNextMsgExpectation{}
	}

	if mmFetchNextMsg.defaultExpectation.params != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Expect")
	}

	if mmFetchNextMsg.defaultExpectation.paramPtrs == nil {
		mmFetchNextMsg.defaultExpectation.paramPtrs = &IOutboxRepositoryMockFetchNextMsgParamPtrs{}
	}
	mmFetchNextMsg.defaultExpectation.paramPtrs.tx = &tx
	mmFetchNextMsg.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmFetchNextMsg
}

// Inspect accepts an inspector function that has same arguments as the IOutboxRepository.FetchNextMsg
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Inspect(f func(ctx context.Context, tx pgx.Tx)) *mIOutboxRepositoryMockFetchNextMsg {
	if mmFetchNextMsg.mock.inspectFuncFetchNextMsg != nil {
		mmFetchNextMsg.mock.t.Fatalf("Inspect function is already set for IOutboxRepositoryMock.FetchNextMsg")
	}

	mmFetchNextMsg.mock.inspectFuncFetchNextMsg = f

	return mmFetchNextMsg
}

// Return sets up results that will be returned by IOutboxRepository.FetchNextMsg
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Return(op1 *models.OutboxEvent, err error) *IOutboxRepositoryMock {
	if mmFetchNextMsg.mock.funcFetchNextMsg != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Set")
	}

	if mmFetchNextMsg.defaultExpectation == nil {
		mmFetchNextMsg.defaultExpectation = &IOutboxRepositoryMockFetchNextMsgExpectation{mock: mmFetchNextMsg.mock}
	}
	mmFetchNextMsg.defaultExpectation.results = &IOutboxRepositoryMockFetchNextMsgResults{op1, err}
	mmFetchNextMsg.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFetchNextMsg.mock
}

// Set uses given function f to mock the IOutboxRepository.FetchNextMsg method
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Set(f func(ctx context.Context, tx pgx.Tx) (op1 *models.OutboxEvent, err error)) *IOutboxRepositoryMock {
	if mmFetchNextMsg.defaultExpectation != nil {
		mmFetchNextMsg.mock.t.Fatalf("Default expectation is already set for the IOutboxRepository.FetchNextMsg method")
	}

	if len(mmFetchNextMsg.expectations) > 0 {
		mmFetchNextMsg.mock.t.Fatalf("Some expectations are already set for the IOutboxRepository.FetchNextMsg method")
	}

	mmFetchNextMsg.mock.funcFetchNextMsg = f
	mmFetchNextMsg.mock.funcFetchNextMsgOrigin = minimock.CallerInfo(1)
	return mmFetchNextMsg.mock
}

// When sets expectation for the IOutboxRepository.FetchNextMsg which will trigger the result defined by the following
// Then helper
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) When(ctx context.Context, tx pgx.Tx) *IOutboxRepositoryMockFetchNextMsgExpectation {
	if mmFetchNextMsg.mock.funcFetchNextMsg != nil {
		mmFetchNextMsg.mock.t.Fatalf("IOutboxRepositoryMock.FetchNextMsg mock is already set by Set")
	}

	expectation := &IOutboxRepositoryMockFetchNextMsgExpectation{
		mock:               mmFetchNextMsg.mock,
		params:             &IOutboxRepositoryMockFetchNextMsgParams{ctx, tx},
		expectationOrigins: IOutboxRepositoryMockFetchNextMsgExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFetchNextMsg.expectations = append(mmFetchNextMsg.expectations, expectation)
	return expectation
}

// Then sets up IOutboxRepository.FetchNextMsg return parameters for the expectation previously defined by the When method
func (e *IOutboxRepositoryMockFetchNextMsgExpectation) Then(op1 *models.OutboxEvent, err error) *IOutboxRepositoryMock {
	e.results = &IOutboxRepositoryMockFetchNextMsgResults{op1, err}
	return e.mock
}

// Times sets number of times IOutboxRepository.FetchNextMsg should be invoked
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Times(n uint64) *mIOutboxRepositoryMockFetchNextMsg {
	if n == 0 {
		mmFetchNextMsg.mock.t.Fatalf("Times of IOutboxRepositoryMock.FetchNextMsg mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFetchNextMsg.expectedInvocations, n)
	mmFetchNextMsg.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFetchNextMsg
}

func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) invocationsDone() bool {
	if len(mmFetchNextMsg.expectations) == 0 && mmFetchNextMsg.defaultExpectation == nil && mmFetchNextMsg.mock.funcFetchNextMsg == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFetchNextMsg.mock.afterFetchNextMsgCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFetchNextMsg.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// FetchNextMsg implements mm_service.IOutboxRepository
func (mmFetchNextMsg *IOutboxRepositoryMock) FetchNextMsg(ctx context.Context, tx pgx.Tx) (op1 *models.OutboxEvent, err error) {
	mm_atomic.AddUint64(&mmFetchNextMsg.beforeFetchNextMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmFetchNextMsg.afterFetchNextMsgCounter, 1)

	mmFetchNextMsg.t.Helper()

	if mmFetchNextMsg.inspectFuncFetchNextMsg != nil {
		mmFetchNextMsg.inspectFuncFetchNextMsg(ctx, tx)
	}

	mm_params := IOutboxRepositoryMockFetchNextMsgParams{ctx, tx}

	// Record call args
	mmFetchNextMsg.FetchNextMsgMock.mutex.Lock()
	mmFetchNextMsg.FetchNextMsgMock.callArgs = append(mmFetchNextMsg.FetchNextMsgMock.callArgs, &mm_params)
	mmFetchNextMsg.FetchNextMsgMock.mutex.Unlock()

	for _, e := range mmFetchNextMsg.FetchNextMsgMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmFetchNextMsg.FetchNextMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.params
		mm_want_ptrs := mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.paramPtrs

		mm_got := IOutboxRepositoryMockFetchNextMsgParams{ctx, tx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFetchNextMsg.t.Errorf("IOutboxRepositoryMock.FetchNextMsg got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmFetchNextMsg.t.Errorf("IOutboxRepositoryMock.FetchNextMsg got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFetchNextMsg.t.Errorf("IOutboxRepositoryMock.FetchNextMsg got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFetchNextMsg.FetchNextMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmFetchNextMsg.t.Fatal("No results are set for the IOutboxRepositoryMock.FetchNextMsg")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmFetchNextMsg.funcFetchNextMsg != nil {
		return mmFetchNextMsg.funcFetchNextMsg(ctx, tx)
	}
	mmFetchNextMsg.t.Fatalf("Unexpected call to IOutboxRepositoryMock.FetchNextMsg. %v %v", ctx, tx)
	return
}

// FetchNextMsgAfterCounter returns a count of finished IOutboxRepositoryMock.FetchNextMsg invocations
func (mmFetchNextMsg *IOutboxRepositoryMock) FetchNextMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchNextMsg.afterFetchNextMsgCounter)
}

// FetchNextMsgBeforeCounter returns a count of IOutboxRepositoryMock.FetchNextMsg invocations
func (mmFetchNextMsg *IOutboxRepositoryMock) FetchNextMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFetchNextMsg.beforeFetchNextMsgCounter)
}

// Calls returns a list of arguments used in each call to IOutboxRepositoryMock.FetchNextMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFetchNextMsg *mIOutboxRepositoryMockFetchNextMsg) Calls() []*IOutboxRepositoryMockFetchNextMsgParams {
	mmFetchNextMsg.mutex.RLock()

	argCopy := make([]*IOutboxRepositoryMockFetchNextMsgParams, len(mmFetchNextMsg.callArgs))
	copy(argCopy, mmFetchNextMsg.callArgs)

	mmFetchNextMsg.mutex.RUnlock()

	return argCopy
}

// MinimockFetchNextMsgDone returns true if the count of the FetchNextMsg invocations corresponds
// the number of defined expectations
func (m *IOutboxRepositoryMock) MinimockFetchNextMsgDone() bool {
	if m.FetchNextMsgMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FetchNextMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FetchNextMsgMock.invocationsDone()
}

// MinimockFetchNextMsgInspect logs each unmet expectation
func (m *IOutboxRepositoryMock) MinimockFetchNextMsgInspect() {
	for _, e := range m.FetchNextMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.FetchNextMsg at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFetchNextMsgCounter := mm_atomic.LoadUint64(&m.afterFetchNextMsgCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FetchNextMsgMock.defaultExpectation != nil && afterFetchNextMsgCounter < 1 {
		if m.FetchNextMsgMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.FetchNextMsg at\n%s", m.FetchNextMsgMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.FetchNextMsg at\n%s with params: %#v", m.FetchNextMsgMock.defaultExpectation.expectationOrigins.origin, *m.FetchNextMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFetchNextMsg != nil && afterFetchNextMsgCounter < 1 {
		m.t.Errorf("Expected call to IOutboxRepositoryMock.FetchNextMsg at\n%s", m.funcFetchNextMsgOrigin)
	}

	if !m.FetchNextMsgMock.invocationsDone() && afterFetchNextMsgCounter > 0 {
		m.t.Errorf("Expected %d calls to IOutboxRepositoryMock.FetchNextMsg at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FetchNextMsgMock.expectedInvocations), m.FetchNextMsgMock.expectedInvocationsOrigin, afterFetchNextMsgCounter)
	}
}

type mIOutboxRepositoryMockMarkAsSent struct {
	optional           bool
	mock               *IOutboxRepositoryMock
	defaultExpectation *IOutboxRepositoryMockMarkAsSentExpectation
	expectations       []*IOutboxRepositoryMockMarkAsSentExpectation

	callArgs []*IOutboxRepositoryMockMarkAsSentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOutboxRepositoryMockMarkAsSentExpectation specifies expectation struct of the IOutboxRepository.MarkAsSent
type IOutboxRepositoryMockMarkAsSentExpectation struct {
	mock               *IOutboxRepositoryMock
	params             *IOutboxRepositoryMockMarkAsSentParams
	paramPtrs          *IOutboxRepositoryMockMarkAsSentParamPtrs
	expectationOrigins IOutboxRepositoryMockMarkAsSentExpectationOrigins
	results            *IOutboxRepositoryMockMarkAsSentResults
	returnOrigin       string
	Counter            uint64
}

// IOutboxRepositoryMockMarkAsSentParams contains parameters of the IOutboxRepository.MarkAsSent
type IOutboxRepositoryMockMarkAsSentParams struct {
	ctx     context.Context
	tx      pgx.Tx
	eventID int64
}

// IOutboxRepositoryMockMarkAsSentParamPtrs contains pointers to parameters of the IOutboxRepository.MarkAsSent
type IOutboxRepositoryMockMarkAsSentParamPtrs struct {
	ctx     *context.Context
	tx      *pgx.Tx
	eventID *int64
}

// IOutboxRepositoryMockMarkAsSentResults contains results of the IOutboxRepository.MarkAsSent
type IOutboxRepositoryMockMarkAsSentResults struct {
	err error
}

// IOutboxRepositoryMockMarkAsSentOrigins contains origins of expectations of the IOutboxRepository.MarkAsSent
type IOutboxRepositoryMockMarkAsSentExpectationOrigins struct {
	origin        string
	originCtx     string
	originTx      string
	originEventID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Optional() *mIOutboxRepositoryMockMarkAsSent {
	mmMarkAsSent.optional = true
	return mmMarkAsSent
}

// Expect sets up expected params for IOutboxRepository.MarkAsSent
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Expect(ctx context.Context, tx pgx.Tx, eventID int64) *mIOutboxRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &IOutboxRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by ExpectParams functions")
	}

	mmMarkAsSent.defaultExpectation.params = &IOutboxRepositoryMockMarkAsSentParams{ctx, tx, eventID}
	mmMarkAsSent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmMarkAsSent.expectations {
		if minimock.Equal(e.params, mmMarkAsSent.defaultExpectation.params) {
			mmMarkAsSent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMarkAsSent.defaultExpectation.params)
		}
	}

	return mmMarkAsSent
}

// ExpectCtxParam1 sets up expected param ctx for IOutboxRepository.MarkAsSent
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) ExpectCtxParam1(ctx context.Context) *mIOutboxRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &IOutboxRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.ctx = &ctx
	mmMarkAsSent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// ExpectTxParam2 sets up expected param tx for IOutboxRepository.MarkAsSent
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) ExpectTxParam2(tx pgx.Tx) *mIOutboxRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &IOutboxRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.tx = &tx
	mmMarkAsSent.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// ExpectEventIDParam3 sets up expected param eventID for IOutboxRepository.MarkAsSent
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) ExpectEventIDParam3(eventID int64) *mIOutboxRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &IOutboxRepositoryMockMarkAsSentExpectation{}
	}

	if mmMarkAsSent.defaultExpectation.params != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Expect")
	}

	if mmMarkAsSent.defaultExpectation.paramPtrs == nil {
		mmMarkAsSent.defaultExpectation.paramPtrs = &IOutboxRepositoryMockMarkAsSentParamPtrs{}
	}
	mmMarkAsSent.defaultExpectation.paramPtrs.eventID = &eventID
	mmMarkAsSent.defaultExpectation.expectationOrigins.originEventID = minimock.CallerInfo(1)

	return mmMarkAsSent
}

// Inspect accepts an inspector function that has same arguments as the IOutboxRepository.MarkAsSent
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Inspect(f func(ctx context.Context, tx pgx.Tx, eventID int64)) *mIOutboxRepositoryMockMarkAsSent {
	if mmMarkAsSent.mock.inspectFuncMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("Inspect function is already set for IOutboxRepositoryMock.MarkAsSent")
	}

	mmMarkAsSent.mock.inspectFuncMarkAsSent = f

	return mmMarkAsSent
}

// Return sets up results that will be returned by IOutboxRepository.MarkAsSent
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Return(err error) *IOutboxRepositoryMock {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Set")
	}

	if mmMarkAsSent.defaultExpectation == nil {
		mmMarkAsSent.defaultExpectation = &IOutboxRepositoryMockMarkAsSentExpectation{mock: mmMarkAsSent.mock}
	}
	mmMarkAsSent.defaultExpectation.results = &IOutboxRepositoryMockMarkAsSentResults{err}
	mmMarkAsSent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent.mock
}

// Set uses given function f to mock the IOutboxRepository.MarkAsSent method
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Set(f func(ctx context.Context, tx pgx.Tx, eventID int64) (err error)) *IOutboxRepositoryMock {
	if mmMarkAsSent.defaultExpectation != nil {
		mmMarkAsSent.mock.t.Fatalf("Default expectation is already set for the IOutboxRepository.MarkAsSent method")
	}

	if len(mmMarkAsSent.expectations) > 0 {
		mmMarkAsSent.mock.t.Fatalf("Some expectations are already set for the IOutboxRepository.MarkAsSent method")
	}

	mmMarkAsSent.mock.funcMarkAsSent = f
	mmMarkAsSent.mock.funcMarkAsSentOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent.mock
}

// When sets expectation for the IOutboxRepository.MarkAsSent which will trigger the result defined by the following
// Then helper
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) When(ctx context.Context, tx pgx.Tx, eventID int64) *IOutboxRepositoryMockMarkAsSentExpectation {
	if mmMarkAsSent.mock.funcMarkAsSent != nil {
		mmMarkAsSent.mock.t.Fatalf("IOutboxRepositoryMock.MarkAsSent mock is already set by Set")
	}

	expectation := &IOutboxRepositoryMockMarkAsSentExpectation{
		mock:               mmMarkAsSent.mock,
		params:             &IOutboxRepositoryMockMarkAsSentParams{ctx, tx, eventID},
		expectationOrigins: IOutboxRepositoryMockMarkAsSentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmMarkAsSent.expectations = append(mmMarkAsSent.expectations, expectation)
	return expectation
}

// Then sets up IOutboxRepository.MarkAsSent return parameters for the expectation previously defined by the When method
func (e *IOutboxRepositoryMockMarkAsSentExpectation) Then(err error) *IOutboxRepositoryMock {
	e.results = &IOutboxRepositoryMockMarkAsSentResults{err}
	return e.mock
}

// Times sets number of times IOutboxRepository.MarkAsSent should be invoked
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Times(n uint64) *mIOutboxRepositoryMockMarkAsSent {
	if n == 0 {
		mmMarkAsSent.mock.t.Fatalf("Times of IOutboxRepositoryMock.MarkAsSent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmMarkAsSent.expectedInvocations, n)
	mmMarkAsSent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmMarkAsSent
}

func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) invocationsDone() bool {
	if len(mmMarkAsSent.expectations) == 0 && mmMarkAsSent.defaultExpectation == nil && mmMarkAsSent.mock.funcMarkAsSent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmMarkAsSent.mock.afterMarkAsSentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmMarkAsSent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// MarkAsSent implements mm_service.IOutboxRepository
func (mmMarkAsSent *IOutboxRepositoryMock) MarkAsSent(ctx context.Context, tx pgx.Tx, eventID int64) (err error) {
	mm_atomic.AddUint64(&mmMarkAsSent.beforeMarkAsSentCounter, 1)
	defer mm_atomic.AddUint64(&mmMarkAsSent.afterMarkAsSentCounter, 1)

	mmMarkAsSent.t.Helper()

	if mmMarkAsSent.inspectFuncMarkAsSent != nil {
		mmMarkAsSent.inspectFuncMarkAsSent(ctx, tx, eventID)
	}

	mm_params := IOutboxRepositoryMockMarkAsSentParams{ctx, tx, eventID}

	// Record call args
	mmMarkAsSent.MarkAsSentMock.mutex.Lock()
	mmMarkAsSent.MarkAsSentMock.callArgs = append(mmMarkAsSent.MarkAsSentMock.callArgs, &mm_params)
	mmMarkAsSent.MarkAsSentMock.mutex.Unlock()

	for _, e := range mmMarkAsSent.MarkAsSentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMarkAsSent.MarkAsSentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMarkAsSent.MarkAsSentMock.defaultExpectation.Counter, 1)
		mm_want := mmMarkAsSent.MarkAsSentMock.defaultExpectation.params
		mm_want_ptrs := mmMarkAsSent.MarkAsSentMock.defaultExpectation.paramPtrs

		mm_got := IOutboxRepositoryMockMarkAsSentParams{ctx, tx, eventID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmMarkAsSent.t.Errorf("IOutboxRepositoryMock.MarkAsSent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmMarkAsSent.t.Errorf("IOutboxRepositoryMock.MarkAsSent got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.eventID != nil && !minimock.Equal(*mm_want_ptrs.eventID, mm_got.eventID) {
				mmMarkAsSent.t.Errorf("IOutboxRepositoryMock.MarkAsSent got unexpected parameter eventID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.originEventID, *mm_want_ptrs.eventID, mm_got.eventID, minimock.Diff(*mm_want_ptrs.eventID, mm_got.eventID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMarkAsSent.t.Errorf("IOutboxRepositoryMock.MarkAsSent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmMarkAsSent.MarkAsSentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMarkAsSent.MarkAsSentMock.defaultExpectation.results
		if mm_results == nil {
			mmMarkAsSent.t.Fatal("No results are set for the IOutboxRepositoryMock.MarkAsSent")
		}
		return (*mm_results).err
	}
	if mmMarkAsSent.funcMarkAsSent != nil {
		return mmMarkAsSent.funcMarkAsSent(ctx, tx, eventID)
	}
	mmMarkAsSent.t.Fatalf("Unexpected call to IOutboxRepositoryMock.MarkAsSent. %v %v %v", ctx, tx, eventID)
	return
}

// MarkAsSentAfterCounter returns a count of finished IOutboxRepositoryMock.MarkAsSent invocations
func (mmMarkAsSent *IOutboxRepositoryMock) MarkAsSentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsSent.afterMarkAsSentCounter)
}

// MarkAsSentBeforeCounter returns a count of IOutboxRepositoryMock.MarkAsSent invocations
func (mmMarkAsSent *IOutboxRepositoryMock) MarkAsSentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMarkAsSent.beforeMarkAsSentCounter)
}

// Calls returns a list of arguments used in each call to IOutboxRepositoryMock.MarkAsSent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMarkAsSent *mIOutboxRepositoryMockMarkAsSent) Calls() []*IOutboxRepositoryMockMarkAsSentParams {
	mmMarkAsSent.mutex.RLock()

	argCopy := make([]*IOutboxRepositoryMockMarkAsSentParams, len(mmMarkAsSent.callArgs))
	copy(argCopy, mmMarkAsSent.callArgs)

	mmMarkAsSent.mutex.RUnlock()

	return argCopy
}

// MinimockMarkAsSentDone returns true if the count of the MarkAsSent invocations corresponds
// the number of defined expectations
func (m *IOutboxRepositoryMock) MinimockMarkAsSentDone() bool {
	if m.MarkAsSentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.MarkAsSentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.MarkAsSentMock.invocationsDone()
}

// MinimockMarkAsSentInspect logs each unmet expectation
func (m *IOutboxRepositoryMock) MinimockMarkAsSentInspect() {
	for _, e := range m.MarkAsSentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.MarkAsSent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterMarkAsSentCounter := mm_atomic.LoadUint64(&m.afterMarkAsSentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.MarkAsSentMock.defaultExpectation != nil && afterMarkAsSentCounter < 1 {
		if m.MarkAsSentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.MarkAsSent at\n%s", m.MarkAsSentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOutboxRepositoryMock.MarkAsSent at\n%s with params: %#v", m.MarkAsSentMock.defaultExpectation.expectationOrigins.origin, *m.MarkAsSentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMarkAsSent != nil && afterMarkAsSentCounter < 1 {
		m.t.Errorf("Expected call to IOutboxRepositoryMock.MarkAsSent at\n%s", m.funcMarkAsSentOrigin)
	}

	if !m.MarkAsSentMock.invocationsDone() && afterMarkAsSentCounter > 0 {
		m.t.Errorf("Expected %d calls to IOutboxRepositoryMock.MarkAsSent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.MarkAsSentMock.expectedInvocations), m.MarkAsSentMock.expectedInvocationsOrigin, afterMarkAsSentCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOutboxRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateEventInspect()

			m.MinimockFetchNextMsgInspect()

			m.MinimockMarkAsSentInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOutboxRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOutboxRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateEventDone() &&
		m.MinimockFetchNextMsgDone() &&
		m.MinimockMarkAsSentDone()
}
