// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.IStockRepository -o stock_repository_mock.go -n IStockRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
)

// IStockRepositoryMock implements mm_service.IStockRepository
type IStockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCancelReservedItems          func(ctx context.Context, tx pgx.Tx, items []models.Item) (err error)
	funcCancelReservedItemsOrigin    string
	inspectFuncCancelReservedItems   func(ctx context.Context, tx pgx.Tx, items []models.Item)
	afterCancelReservedItemsCounter  uint64
	beforeCancelReservedItemsCounter uint64
	CancelReservedItemsMock          mIStockRepositoryMockCancelReservedItems

	funcGetAvailableStockBySKU          func(ctx context.Context, SKU models.SKU) (u1 uint64, err error)
	funcGetAvailableStockBySKUOrigin    string
	inspectFuncGetAvailableStockBySKU   func(ctx context.Context, SKU models.SKU)
	afterGetAvailableStockBySKUCounter  uint64
	beforeGetAvailableStockBySKUCounter uint64
	GetAvailableStockBySKUMock          mIStockRepositoryMockGetAvailableStockBySKU

	funcRemoveReservedItems          func(ctx context.Context, tx pgx.Tx, items []models.Item) (err error)
	funcRemoveReservedItemsOrigin    string
	inspectFuncRemoveReservedItems   func(ctx context.Context, tx pgx.Tx, items []models.Item)
	afterRemoveReservedItemsCounter  uint64
	beforeRemoveReservedItemsCounter uint64
	RemoveReservedItemsMock          mIStockRepositoryMockRemoveReservedItems

	funcReserveItems          func(ctx context.Context, tx pgx.Tx, items []models.Item) (err error)
	funcReserveItemsOrigin    string
	inspectFuncReserveItems   func(ctx context.Context, tx pgx.Tx, items []models.Item)
	afterReserveItemsCounter  uint64
	beforeReserveItemsCounter uint64
	ReserveItemsMock          mIStockRepositoryMockReserveItems
}

// NewIStockRepositoryMock returns a mock for mm_service.IStockRepository
func NewIStockRepositoryMock(t minimock.Tester) *IStockRepositoryMock {
	m := &IStockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelReservedItemsMock = mIStockRepositoryMockCancelReservedItems{mock: m}
	m.CancelReservedItemsMock.callArgs = []*IStockRepositoryMockCancelReservedItemsParams{}

	m.GetAvailableStockBySKUMock = mIStockRepositoryMockGetAvailableStockBySKU{mock: m}
	m.GetAvailableStockBySKUMock.callArgs = []*IStockRepositoryMockGetAvailableStockBySKUParams{}

	m.RemoveReservedItemsMock = mIStockRepositoryMockRemoveReservedItems{mock: m}
	m.RemoveReservedItemsMock.callArgs = []*IStockRepositoryMockRemoveReservedItemsParams{}

	m.ReserveItemsMock = mIStockRepositoryMockReserveItems{mock: m}
	m.ReserveItemsMock.callArgs = []*IStockRepositoryMockReserveItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIStockRepositoryMockCancelReservedItems struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockCancelReservedItemsExpectation
	expectations       []*IStockRepositoryMockCancelReservedItemsExpectation

	callArgs []*IStockRepositoryMockCancelReservedItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockCancelReservedItemsExpectation specifies expectation struct of the IStockRepository.CancelReservedItems
type IStockRepositoryMockCancelReservedItemsExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockCancelReservedItemsParams
	paramPtrs          *IStockRepositoryMockCancelReservedItemsParamPtrs
	expectationOrigins IStockRepositoryMockCancelReservedItemsExpectationOrigins
	results            *IStockRepositoryMockCancelReservedItemsResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockCancelReservedItemsParams contains parameters of the IStockRepository.CancelReservedItems
type IStockRepositoryMockCancelReservedItemsParams struct {
	ctx   context.Context
	tx    pgx.Tx
	items []models.Item
}

// IStockRepositoryMockCancelReservedItemsParamPtrs contains pointers to parameters of the IStockRepository.CancelReservedItems
type IStockRepositoryMockCancelReservedItemsParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	items *[]models.Item
}

// IStockRepositoryMockCancelReservedItemsResults contains results of the IStockRepository.CancelReservedItems
type IStockRepositoryMockCancelReservedItemsResults struct {
	err error
}

// IStockRepositoryMockCancelReservedItemsOrigins contains origins of expectations of the IStockRepository.CancelReservedItems
type IStockRepositoryMockCancelReservedItemsExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Optional() *mIStockRepositoryMockCancelReservedItems {
	mmCancelReservedItems.optional = true
	return mmCancelReservedItems
}

// Expect sets up expected params for IStockRepository.CancelReservedItems
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Expect(ctx context.Context, tx pgx.Tx, items []models.Item) *mIStockRepositoryMockCancelReservedItems {
	if mmCancelReservedItems.mock.funcCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Set")
	}

	if mmCancelReservedItems.defaultExpectation == nil {
		mmCancelReservedItems.defaultExpectation = &IStockRepositoryMockCancelReservedItemsExpectation{}
	}

	if mmCancelReservedItems.defaultExpectation.paramPtrs != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by ExpectParams functions")
	}

	mmCancelReservedItems.defaultExpectation.params = &IStockRepositoryMockCancelReservedItemsParams{ctx, tx, items}
	mmCancelReservedItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancelReservedItems.expectations {
		if minimock.Equal(e.params, mmCancelReservedItems.defaultExpectation.params) {
			mmCancelReservedItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelReservedItems.defaultExpectation.params)
		}
	}

	return mmCancelReservedItems
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepository.CancelReservedItems
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) ExpectCtxParam1(ctx context.Context) *mIStockRepositoryMockCancelReservedItems {
	if mmCancelReservedItems.mock.funcCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Set")
	}

	if mmCancelReservedItems.defaultExpectation == nil {
		mmCancelReservedItems.defaultExpectation = &IStockRepositoryMockCancelReservedItemsExpectation{}
	}

	if mmCancelReservedItems.defaultExpectation.params != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Expect")
	}

	if mmCancelReservedItems.defaultExpectation.paramPtrs == nil {
		mmCancelReservedItems.defaultExpectation.paramPtrs = &IStockRepositoryMockCancelReservedItemsParamPtrs{}
	}
	mmCancelReservedItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmCancelReservedItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCancelReservedItems
}

// ExpectTxParam2 sets up expected param tx for IStockRepository.CancelReservedItems
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) ExpectTxParam2(tx pgx.Tx) *mIStockRepositoryMockCancelReservedItems {
	if mmCancelReservedItems.mock.funcCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Set")
	}

	if mmCancelReservedItems.defaultExpectation == nil {
		mmCancelReservedItems.defaultExpectation = &IStockRepositoryMockCancelReservedItemsExpectation{}
	}

	if mmCancelReservedItems.defaultExpectation.params != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Expect")
	}

	if mmCancelReservedItems.defaultExpectation.paramPtrs == nil {
		mmCancelReservedItems.defaultExpectation.paramPtrs = &IStockRepositoryMockCancelReservedItemsParamPtrs{}
	}
	mmCancelReservedItems.defaultExpectation.paramPtrs.tx = &tx
	mmCancelReservedItems.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmCancelReservedItems
}

// ExpectItemsParam3 sets up expected param items for IStockRepository.CancelReservedItems
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) ExpectItemsParam3(items []models.Item) *mIStockRepositoryMockCancelReservedItems {
	if mmCancelReservedItems.mock.funcCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Set")
	}

	if mmCancelReservedItems.defaultExpectation == nil {
		mmCancelReservedItems.defaultExpectation = &IStockRepositoryMockCancelReservedItemsExpectation{}
	}

	if mmCancelReservedItems.defaultExpectation.params != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Expect")
	}

	if mmCancelReservedItems.defaultExpectation.paramPtrs == nil {
		mmCancelReservedItems.defaultExpectation.paramPtrs = &IStockRepositoryMockCancelReservedItemsParamPtrs{}
	}
	mmCancelReservedItems.defaultExpectation.paramPtrs.items = &items
	mmCancelReservedItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmCancelReservedItems
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.CancelReservedItems
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Inspect(f func(ctx context.Context, tx pgx.Tx, items []models.Item)) *mIStockRepositoryMockCancelReservedItems {
	if mmCancelReservedItems.mock.inspectFuncCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.CancelReservedItems")
	}

	mmCancelReservedItems.mock.inspectFuncCancelReservedItems = f

	return mmCancelReservedItems
}

// Return sets up results that will be returned by IStockRepository.CancelReservedItems
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Return(err error) *IStockRepositoryMock {
	if mmCancelReservedItems.mock.funcCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Set")
	}

	if mmCancelReservedItems.defaultExpectation == nil {
		mmCancelReservedItems.defaultExpectation = &IStockRepositoryMockCancelReservedItemsExpectation{mock: mmCancelReservedItems.mock}
	}
	mmCancelReservedItems.defaultExpectation.results = &IStockRepositoryMockCancelReservedItemsResults{err}
	mmCancelReservedItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancelReservedItems.mock
}

// Set uses given function f to mock the IStockRepository.CancelReservedItems method
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Set(f func(ctx context.Context, tx pgx.Tx, items []models.Item) (err error)) *IStockRepositoryMock {
	if mmCancelReservedItems.defaultExpectation != nil {
		mmCancelReservedItems.mock.t.Fatalf("Default expectation is already set for the IStockRepository.CancelReservedItems method")
	}

	if len(mmCancelReservedItems.expectations) > 0 {
		mmCancelReservedItems.mock.t.Fatalf("Some expectations are already set for the IStockRepository.CancelReservedItems method")
	}

	mmCancelReservedItems.mock.funcCancelReservedItems = f
	mmCancelReservedItems.mock.funcCancelReservedItemsOrigin = minimock.CallerInfo(1)
	return mmCancelReservedItems.mock
}

// When sets expectation for the IStockRepository.CancelReservedItems which will trigger the result defined by the following
// Then helper
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) When(ctx context.Context, tx pgx.Tx, items []models.Item) *IStockRepositoryMockCancelReservedItemsExpectation {
	if mmCancelReservedItems.mock.funcCancelReservedItems != nil {
		mmCancelReservedItems.mock.t.Fatalf("IStockRepositoryMock.CancelReservedItems mock is already set by Set")
	}

	expectation := &IStockRepositoryMockCancelReservedItemsExpectation{
		mock:               mmCancelReservedItems.mock,
		params:             &IStockRepositoryMockCancelReservedItemsParams{ctx, tx, items},
		expectationOrigins: IStockRepositoryMockCancelReservedItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancelReservedItems.expectations = append(mmCancelReservedItems.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.CancelReservedItems return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockCancelReservedItemsExpectation) Then(err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockCancelReservedItemsResults{err}
	return e.mock
}

// Times sets number of times IStockRepository.CancelReservedItems should be invoked
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Times(n uint64) *mIStockRepositoryMockCancelReservedItems {
	if n == 0 {
		mmCancelReservedItems.mock.t.Fatalf("Times of IStockRepositoryMock.CancelReservedItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancelReservedItems.expectedInvocations, n)
	mmCancelReservedItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancelReservedItems
}

func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) invocationsDone() bool {
	if len(mmCancelReservedItems.expectations) == 0 && mmCancelReservedItems.defaultExpectation == nil && mmCancelReservedItems.mock.funcCancelReservedItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancelReservedItems.mock.afterCancelReservedItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancelReservedItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CancelReservedItems implements mm_service.IStockRepository
func (mmCancelReservedItems *IStockRepositoryMock) CancelReservedItems(ctx context.Context, tx pgx.Tx, items []models.Item) (err error) {
	mm_atomic.AddUint64(&mmCancelReservedItems.beforeCancelReservedItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelReservedItems.afterCancelReservedItemsCounter, 1)

	mmCancelReservedItems.t.Helper()

	if mmCancelReservedItems.inspectFuncCancelReservedItems != nil {
		mmCancelReservedItems.inspectFuncCancelReservedItems(ctx, tx, items)
	}

	mm_params := IStockRepositoryMockCancelReservedItemsParams{ctx, tx, items}

	// Record call args
	mmCancelReservedItems.CancelReservedItemsMock.mutex.Lock()
	mmCancelReservedItems.CancelReservedItemsMock.callArgs = append(mmCancelReservedItems.CancelReservedItemsMock.callArgs, &mm_params)
	mmCancelReservedItems.CancelReservedItemsMock.mutex.Unlock()

	for _, e := range mmCancelReservedItems.CancelReservedItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.params
		mm_want_ptrs := mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockCancelReservedItemsParams{ctx, tx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancelReservedItems.t.Errorf("IStockRepositoryMock.CancelReservedItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmCancelReservedItems.t.Errorf("IStockRepositoryMock.CancelReservedItems got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCancelReservedItems.t.Errorf("IStockRepositoryMock.CancelReservedItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelReservedItems.t.Errorf("IStockRepositoryMock.CancelReservedItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelReservedItems.CancelReservedItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelReservedItems.t.Fatal("No results are set for the IStockRepositoryMock.CancelReservedItems")
		}
		return (*mm_results).err
	}
	if mmCancelReservedItems.funcCancelReservedItems != nil {
		return mmCancelReservedItems.funcCancelReservedItems(ctx, tx, items)
	}
	mmCancelReservedItems.t.Fatalf("Unexpected call to IStockRepositoryMock.CancelReservedItems. %v %v %v", ctx, tx, items)
	return
}

// CancelReservedItemsAfterCounter returns a count of finished IStockRepositoryMock.CancelReservedItems invocations
func (mmCancelReservedItems *IStockRepositoryMock) CancelReservedItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReservedItems.afterCancelReservedItemsCounter)
}

// CancelReservedItemsBeforeCounter returns a count of IStockRepositoryMock.CancelReservedItems invocations
func (mmCancelReservedItems *IStockRepositoryMock) CancelReservedItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelReservedItems.beforeCancelReservedItemsCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.CancelReservedItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelReservedItems *mIStockRepositoryMockCancelReservedItems) Calls() []*IStockRepositoryMockCancelReservedItemsParams {
	mmCancelReservedItems.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockCancelReservedItemsParams, len(mmCancelReservedItems.callArgs))
	copy(argCopy, mmCancelReservedItems.callArgs)

	mmCancelReservedItems.mutex.RUnlock()

	return argCopy
}

// MinimockCancelReservedItemsDone returns true if the count of the CancelReservedItems invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockCancelReservedItemsDone() bool {
	if m.CancelReservedItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelReservedItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelReservedItemsMock.invocationsDone()
}

// MinimockCancelReservedItemsInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockCancelReservedItemsInspect() {
	for _, e := range m.CancelReservedItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.CancelReservedItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelReservedItemsCounter := mm_atomic.LoadUint64(&m.afterCancelReservedItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelReservedItemsMock.defaultExpectation != nil && afterCancelReservedItemsCounter < 1 {
		if m.CancelReservedItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.CancelReservedItems at\n%s", m.CancelReservedItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.CancelReservedItems at\n%s with params: %#v", m.CancelReservedItemsMock.defaultExpectation.expectationOrigins.origin, *m.CancelReservedItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelReservedItems != nil && afterCancelReservedItemsCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.CancelReservedItems at\n%s", m.funcCancelReservedItemsOrigin)
	}

	if !m.CancelReservedItemsMock.invocationsDone() && afterCancelReservedItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.CancelReservedItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelReservedItemsMock.expectedInvocations), m.CancelReservedItemsMock.expectedInvocationsOrigin, afterCancelReservedItemsCounter)
	}
}

type mIStockRepositoryMockGetAvailableStockBySKU struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockGetAvailableStockBySKUExpectation
	expectations       []*IStockRepositoryMockGetAvailableStockBySKUExpectation

	callArgs []*IStockRepositoryMockGetAvailableStockBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockGetAvailableStockBySKUExpectation specifies expectation struct of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockGetAvailableStockBySKUParams
	paramPtrs          *IStockRepositoryMockGetAvailableStockBySKUParamPtrs
	expectationOrigins IStockRepositoryMockGetAvailableStockBySKUExpectationOrigins
	results            *IStockRepositoryMockGetAvailableStockBySKUResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockGetAvailableStockBySKUParams contains parameters of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUParams struct {
	ctx context.Context
	SKU models.SKU
}

// IStockRepositoryMockGetAvailableStockBySKUParamPtrs contains pointers to parameters of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUParamPtrs struct {
	ctx *context.Context
	SKU *models.SKU
}

// IStockRepositoryMockGetAvailableStockBySKUResults contains results of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUResults struct {
	u1  uint64
	err error
}

// IStockRepositoryMockGetAvailableStockBySKUOrigins contains origins of expectations of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSKU string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Optional() *mIStockRepositoryMockGetAvailableStockBySKU {
	mmGetAvailableStockBySKU.optional = true
	return mmGetAvailableStockBySKU
}

// Expect sets up expected params for IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Expect(ctx context.Context, SKU models.SKU) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{}
	}

	if mmGetAvailableStockBySKU.defaultExpectation.paramPtrs != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by ExpectParams functions")
	}

	mmGetAvailableStockBySKU.defaultExpectation.params = &IStockRepositoryMockGetAvailableStockBySKUParams{ctx, SKU}
	mmGetAvailableStockBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAvailableStockBySKU.expectations {
		if minimock.Equal(e.params, mmGetAvailableStockBySKU.defaultExpectation.params) {
			mmGetAvailableStockBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAvailableStockBySKU.defaultExpectation.params)
		}
	}

	return mmGetAvailableStockBySKU
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) ExpectCtxParam1(ctx context.Context) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{}
	}

	if mmGetAvailableStockBySKU.defaultExpectation.params != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Expect")
	}

	if mmGetAvailableStockBySKU.defaultExpectation.paramPtrs == nil {
		mmGetAvailableStockBySKU.defaultExpectation.paramPtrs = &IStockRepositoryMockGetAvailableStockBySKUParamPtrs{}
	}
	mmGetAvailableStockBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAvailableStockBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAvailableStockBySKU
}

// ExpectSKUParam2 sets up expected param SKU for IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) ExpectSKUParam2(SKU models.SKU) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{}
	}

	if mmGetAvailableStockBySKU.defaultExpectation.params != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Expect")
	}

	if mmGetAvailableStockBySKU.defaultExpectation.paramPtrs == nil {
		mmGetAvailableStockBySKU.defaultExpectation.paramPtrs = &IStockRepositoryMockGetAvailableStockBySKUParamPtrs{}
	}
	mmGetAvailableStockBySKU.defaultExpectation.paramPtrs.SKU = &SKU
	mmGetAvailableStockBySKU.defaultExpectation.expectationOrigins.originSKU = minimock.CallerInfo(1)

	return mmGetAvailableStockBySKU
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Inspect(f func(ctx context.Context, SKU models.SKU)) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.inspectFuncGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.GetAvailableStockBySKU")
	}

	mmGetAvailableStockBySKU.mock.inspectFuncGetAvailableStockBySKU = f

	return mmGetAvailableStockBySKU
}

// Return sets up results that will be returned by IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Return(u1 uint64, err error) *IStockRepositoryMock {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{mock: mmGetAvailableStockBySKU.mock}
	}
	mmGetAvailableStockBySKU.defaultExpectation.results = &IStockRepositoryMockGetAvailableStockBySKUResults{u1, err}
	mmGetAvailableStockBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAvailableStockBySKU.mock
}

// Set uses given function f to mock the IStockRepository.GetAvailableStockBySKU method
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Set(f func(ctx context.Context, SKU models.SKU) (u1 uint64, err error)) *IStockRepositoryMock {
	if mmGetAvailableStockBySKU.defaultExpectation != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Default expectation is already set for the IStockRepository.GetAvailableStockBySKU method")
	}

	if len(mmGetAvailableStockBySKU.expectations) > 0 {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Some expectations are already set for the IStockRepository.GetAvailableStockBySKU method")
	}

	mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU = f
	mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKUOrigin = minimock.CallerInfo(1)
	return mmGetAvailableStockBySKU.mock
}

// When sets expectation for the IStockRepository.GetAvailableStockBySKU which will trigger the result defined by the following
// Then helper
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) When(ctx context.Context, SKU models.SKU) *IStockRepositoryMockGetAvailableStockBySKUExpectation {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	expectation := &IStockRepositoryMockGetAvailableStockBySKUExpectation{
		mock:               mmGetAvailableStockBySKU.mock,
		params:             &IStockRepositoryMockGetAvailableStockBySKUParams{ctx, SKU},
		expectationOrigins: IStockRepositoryMockGetAvailableStockBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAvailableStockBySKU.expectations = append(mmGetAvailableStockBySKU.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.GetAvailableStockBySKU return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockGetAvailableStockBySKUExpectation) Then(u1 uint64, err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockGetAvailableStockBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times IStockRepository.GetAvailableStockBySKU should be invoked
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Times(n uint64) *mIStockRepositoryMockGetAvailableStockBySKU {
	if n == 0 {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Times of IStockRepositoryMock.GetAvailableStockBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAvailableStockBySKU.expectedInvocations, n)
	mmGetAvailableStockBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAvailableStockBySKU
}

func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) invocationsDone() bool {
	if len(mmGetAvailableStockBySKU.expectations) == 0 && mmGetAvailableStockBySKU.defaultExpectation == nil && mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.mock.afterGetAvailableStockBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAvailableStockBySKU implements mm_service.IStockRepository
func (mmGetAvailableStockBySKU *IStockRepositoryMock) GetAvailableStockBySKU(ctx context.Context, SKU models.SKU) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetAvailableStockBySKU.beforeGetAvailableStockBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAvailableStockBySKU.afterGetAvailableStockBySKUCounter, 1)

	mmGetAvailableStockBySKU.t.Helper()

	if mmGetAvailableStockBySKU.inspectFuncGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.inspectFuncGetAvailableStockBySKU(ctx, SKU)
	}

	mm_params := IStockRepositoryMockGetAvailableStockBySKUParams{ctx, SKU}

	// Record call args
	mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.mutex.Lock()
	mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.callArgs = append(mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.callArgs, &mm_params)
	mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.mutex.Unlock()

	for _, e := range mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockGetAvailableStockBySKUParams{ctx, SKU}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAvailableStockBySKU.t.Errorf("IStockRepositoryMock.GetAvailableStockBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.SKU != nil && !minimock.Equal(*mm_want_ptrs.SKU, mm_got.SKU) {
				mmGetAvailableStockBySKU.t.Errorf("IStockRepositoryMock.GetAvailableStockBySKU got unexpected parameter SKU, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.originSKU, *mm_want_ptrs.SKU, mm_got.SKU, minimock.Diff(*mm_want_ptrs.SKU, mm_got.SKU))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAvailableStockBySKU.t.Errorf("IStockRepositoryMock.GetAvailableStockBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAvailableStockBySKU.t.Fatal("No results are set for the IStockRepositoryMock.GetAvailableStockBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetAvailableStockBySKU.funcGetAvailableStockBySKU != nil {
		return mmGetAvailableStockBySKU.funcGetAvailableStockBySKU(ctx, SKU)
	}
	mmGetAvailableStockBySKU.t.Fatalf("Unexpected call to IStockRepositoryMock.GetAvailableStockBySKU. %v %v", ctx, SKU)
	return
}

// GetAvailableStockBySKUAfterCounter returns a count of finished IStockRepositoryMock.GetAvailableStockBySKU invocations
func (mmGetAvailableStockBySKU *IStockRepositoryMock) GetAvailableStockBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.afterGetAvailableStockBySKUCounter)
}

// GetAvailableStockBySKUBeforeCounter returns a count of IStockRepositoryMock.GetAvailableStockBySKU invocations
func (mmGetAvailableStockBySKU *IStockRepositoryMock) GetAvailableStockBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.beforeGetAvailableStockBySKUCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.GetAvailableStockBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Calls() []*IStockRepositoryMockGetAvailableStockBySKUParams {
	mmGetAvailableStockBySKU.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockGetAvailableStockBySKUParams, len(mmGetAvailableStockBySKU.callArgs))
	copy(argCopy, mmGetAvailableStockBySKU.callArgs)

	mmGetAvailableStockBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetAvailableStockBySKUDone returns true if the count of the GetAvailableStockBySKU invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockGetAvailableStockBySKUDone() bool {
	if m.GetAvailableStockBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAvailableStockBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAvailableStockBySKUMock.invocationsDone()
}

// MinimockGetAvailableStockBySKUInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockGetAvailableStockBySKUInspect() {
	for _, e := range m.GetAvailableStockBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAvailableStockBySKUCounter := mm_atomic.LoadUint64(&m.afterGetAvailableStockBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableStockBySKUMock.defaultExpectation != nil && afterGetAvailableStockBySKUCounter < 1 {
		if m.GetAvailableStockBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s", m.GetAvailableStockBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s with params: %#v", m.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetAvailableStockBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableStockBySKU != nil && afterGetAvailableStockBySKUCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s", m.funcGetAvailableStockBySKUOrigin)
	}

	if !m.GetAvailableStockBySKUMock.invocationsDone() && afterGetAvailableStockBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.GetAvailableStockBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAvailableStockBySKUMock.expectedInvocations), m.GetAvailableStockBySKUMock.expectedInvocationsOrigin, afterGetAvailableStockBySKUCounter)
	}
}

type mIStockRepositoryMockRemoveReservedItems struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockRemoveReservedItemsExpectation
	expectations       []*IStockRepositoryMockRemoveReservedItemsExpectation

	callArgs []*IStockRepositoryMockRemoveReservedItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockRemoveReservedItemsExpectation specifies expectation struct of the IStockRepository.RemoveReservedItems
type IStockRepositoryMockRemoveReservedItemsExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockRemoveReservedItemsParams
	paramPtrs          *IStockRepositoryMockRemoveReservedItemsParamPtrs
	expectationOrigins IStockRepositoryMockRemoveReservedItemsExpectationOrigins
	results            *IStockRepositoryMockRemoveReservedItemsResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockRemoveReservedItemsParams contains parameters of the IStockRepository.RemoveReservedItems
type IStockRepositoryMockRemoveReservedItemsParams struct {
	ctx   context.Context
	tx    pgx.Tx
	items []models.Item
}

// IStockRepositoryMockRemoveReservedItemsParamPtrs contains pointers to parameters of the IStockRepository.RemoveReservedItems
type IStockRepositoryMockRemoveReservedItemsParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	items *[]models.Item
}

// IStockRepositoryMockRemoveReservedItemsResults contains results of the IStockRepository.RemoveReservedItems
type IStockRepositoryMockRemoveReservedItemsResults struct {
	err error
}

// IStockRepositoryMockRemoveReservedItemsOrigins contains origins of expectations of the IStockRepository.RemoveReservedItems
type IStockRepositoryMockRemoveReservedItemsExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Optional() *mIStockRepositoryMockRemoveReservedItems {
	mmRemoveReservedItems.optional = true
	return mmRemoveReservedItems
}

// Expect sets up expected params for IStockRepository.RemoveReservedItems
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Expect(ctx context.Context, tx pgx.Tx, items []models.Item) *mIStockRepositoryMockRemoveReservedItems {
	if mmRemoveReservedItems.mock.funcRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Set")
	}

	if mmRemoveReservedItems.defaultExpectation == nil {
		mmRemoveReservedItems.defaultExpectation = &IStockRepositoryMockRemoveReservedItemsExpectation{}
	}

	if mmRemoveReservedItems.defaultExpectation.paramPtrs != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by ExpectParams functions")
	}

	mmRemoveReservedItems.defaultExpectation.params = &IStockRepositoryMockRemoveReservedItemsParams{ctx, tx, items}
	mmRemoveReservedItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveReservedItems.expectations {
		if minimock.Equal(e.params, mmRemoveReservedItems.defaultExpectation.params) {
			mmRemoveReservedItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveReservedItems.defaultExpectation.params)
		}
	}

	return mmRemoveReservedItems
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepository.RemoveReservedItems
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) ExpectCtxParam1(ctx context.Context) *mIStockRepositoryMockRemoveReservedItems {
	if mmRemoveReservedItems.mock.funcRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Set")
	}

	if mmRemoveReservedItems.defaultExpectation == nil {
		mmRemoveReservedItems.defaultExpectation = &IStockRepositoryMockRemoveReservedItemsExpectation{}
	}

	if mmRemoveReservedItems.defaultExpectation.params != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Expect")
	}

	if mmRemoveReservedItems.defaultExpectation.paramPtrs == nil {
		mmRemoveReservedItems.defaultExpectation.paramPtrs = &IStockRepositoryMockRemoveReservedItemsParamPtrs{}
	}
	mmRemoveReservedItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveReservedItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveReservedItems
}

// ExpectTxParam2 sets up expected param tx for IStockRepository.RemoveReservedItems
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) ExpectTxParam2(tx pgx.Tx) *mIStockRepositoryMockRemoveReservedItems {
	if mmRemoveReservedItems.mock.funcRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Set")
	}

	if mmRemoveReservedItems.defaultExpectation == nil {
		mmRemoveReservedItems.defaultExpectation = &IStockRepositoryMockRemoveReservedItemsExpectation{}
	}

	if mmRemoveReservedItems.defaultExpectation.params != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Expect")
	}

	if mmRemoveReservedItems.defaultExpectation.paramPtrs == nil {
		mmRemoveReservedItems.defaultExpectation.paramPtrs = &IStockRepositoryMockRemoveReservedItemsParamPtrs{}
	}
	mmRemoveReservedItems.defaultExpectation.paramPtrs.tx = &tx
	mmRemoveReservedItems.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmRemoveReservedItems
}

// ExpectItemsParam3 sets up expected param items for IStockRepository.RemoveReservedItems
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) ExpectItemsParam3(items []models.Item) *mIStockRepositoryMockRemoveReservedItems {
	if mmRemoveReservedItems.mock.funcRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Set")
	}

	if mmRemoveReservedItems.defaultExpectation == nil {
		mmRemoveReservedItems.defaultExpectation = &IStockRepositoryMockRemoveReservedItemsExpectation{}
	}

	if mmRemoveReservedItems.defaultExpectation.params != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Expect")
	}

	if mmRemoveReservedItems.defaultExpectation.paramPtrs == nil {
		mmRemoveReservedItems.defaultExpectation.paramPtrs = &IStockRepositoryMockRemoveReservedItemsParamPtrs{}
	}
	mmRemoveReservedItems.defaultExpectation.paramPtrs.items = &items
	mmRemoveReservedItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmRemoveReservedItems
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.RemoveReservedItems
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Inspect(f func(ctx context.Context, tx pgx.Tx, items []models.Item)) *mIStockRepositoryMockRemoveReservedItems {
	if mmRemoveReservedItems.mock.inspectFuncRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.RemoveReservedItems")
	}

	mmRemoveReservedItems.mock.inspectFuncRemoveReservedItems = f

	return mmRemoveReservedItems
}

// Return sets up results that will be returned by IStockRepository.RemoveReservedItems
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Return(err error) *IStockRepositoryMock {
	if mmRemoveReservedItems.mock.funcRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Set")
	}

	if mmRemoveReservedItems.defaultExpectation == nil {
		mmRemoveReservedItems.defaultExpectation = &IStockRepositoryMockRemoveReservedItemsExpectation{mock: mmRemoveReservedItems.mock}
	}
	mmRemoveReservedItems.defaultExpectation.results = &IStockRepositoryMockRemoveReservedItemsResults{err}
	mmRemoveReservedItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveReservedItems.mock
}

// Set uses given function f to mock the IStockRepository.RemoveReservedItems method
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Set(f func(ctx context.Context, tx pgx.Tx, items []models.Item) (err error)) *IStockRepositoryMock {
	if mmRemoveReservedItems.defaultExpectation != nil {
		mmRemoveReservedItems.mock.t.Fatalf("Default expectation is already set for the IStockRepository.RemoveReservedItems method")
	}

	if len(mmRemoveReservedItems.expectations) > 0 {
		mmRemoveReservedItems.mock.t.Fatalf("Some expectations are already set for the IStockRepository.RemoveReservedItems method")
	}

	mmRemoveReservedItems.mock.funcRemoveReservedItems = f
	mmRemoveReservedItems.mock.funcRemoveReservedItemsOrigin = minimock.CallerInfo(1)
	return mmRemoveReservedItems.mock
}

// When sets expectation for the IStockRepository.RemoveReservedItems which will trigger the result defined by the following
// Then helper
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) When(ctx context.Context, tx pgx.Tx, items []models.Item) *IStockRepositoryMockRemoveReservedItemsExpectation {
	if mmRemoveReservedItems.mock.funcRemoveReservedItems != nil {
		mmRemoveReservedItems.mock.t.Fatalf("IStockRepositoryMock.RemoveReservedItems mock is already set by Set")
	}

	expectation := &IStockRepositoryMockRemoveReservedItemsExpectation{
		mock:               mmRemoveReservedItems.mock,
		params:             &IStockRepositoryMockRemoveReservedItemsParams{ctx, tx, items},
		expectationOrigins: IStockRepositoryMockRemoveReservedItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveReservedItems.expectations = append(mmRemoveReservedItems.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.RemoveReservedItems return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockRemoveReservedItemsExpectation) Then(err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockRemoveReservedItemsResults{err}
	return e.mock
}

// Times sets number of times IStockRepository.RemoveReservedItems should be invoked
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Times(n uint64) *mIStockRepositoryMockRemoveReservedItems {
	if n == 0 {
		mmRemoveReservedItems.mock.t.Fatalf("Times of IStockRepositoryMock.RemoveReservedItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveReservedItems.expectedInvocations, n)
	mmRemoveReservedItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveReservedItems
}

func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) invocationsDone() bool {
	if len(mmRemoveReservedItems.expectations) == 0 && mmRemoveReservedItems.defaultExpectation == nil && mmRemoveReservedItems.mock.funcRemoveReservedItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveReservedItems.mock.afterRemoveReservedItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveReservedItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveReservedItems implements mm_service.IStockRepository
func (mmRemoveReservedItems *IStockRepositoryMock) RemoveReservedItems(ctx context.Context, tx pgx.Tx, items []models.Item) (err error) {
	mm_atomic.AddUint64(&mmRemoveReservedItems.beforeRemoveReservedItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveReservedItems.afterRemoveReservedItemsCounter, 1)

	mmRemoveReservedItems.t.Helper()

	if mmRemoveReservedItems.inspectFuncRemoveReservedItems != nil {
		mmRemoveReservedItems.inspectFuncRemoveReservedItems(ctx, tx, items)
	}

	mm_params := IStockRepositoryMockRemoveReservedItemsParams{ctx, tx, items}

	// Record call args
	mmRemoveReservedItems.RemoveReservedItemsMock.mutex.Lock()
	mmRemoveReservedItems.RemoveReservedItemsMock.callArgs = append(mmRemoveReservedItems.RemoveReservedItemsMock.callArgs, &mm_params)
	mmRemoveReservedItems.RemoveReservedItemsMock.mutex.Unlock()

	for _, e := range mmRemoveReservedItems.RemoveReservedItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockRemoveReservedItemsParams{ctx, tx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveReservedItems.t.Errorf("IStockRepositoryMock.RemoveReservedItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmRemoveReservedItems.t.Errorf("IStockRepositoryMock.RemoveReservedItems got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmRemoveReservedItems.t.Errorf("IStockRepositoryMock.RemoveReservedItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveReservedItems.t.Errorf("IStockRepositoryMock.RemoveReservedItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveReservedItems.RemoveReservedItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveReservedItems.t.Fatal("No results are set for the IStockRepositoryMock.RemoveReservedItems")
		}
		return (*mm_results).err
	}
	if mmRemoveReservedItems.funcRemoveReservedItems != nil {
		return mmRemoveReservedItems.funcRemoveReservedItems(ctx, tx, items)
	}
	mmRemoveReservedItems.t.Fatalf("Unexpected call to IStockRepositoryMock.RemoveReservedItems. %v %v %v", ctx, tx, items)
	return
}

// RemoveReservedItemsAfterCounter returns a count of finished IStockRepositoryMock.RemoveReservedItems invocations
func (mmRemoveReservedItems *IStockRepositoryMock) RemoveReservedItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveReservedItems.afterRemoveReservedItemsCounter)
}

// RemoveReservedItemsBeforeCounter returns a count of IStockRepositoryMock.RemoveReservedItems invocations
func (mmRemoveReservedItems *IStockRepositoryMock) RemoveReservedItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveReservedItems.beforeRemoveReservedItemsCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.RemoveReservedItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveReservedItems *mIStockRepositoryMockRemoveReservedItems) Calls() []*IStockRepositoryMockRemoveReservedItemsParams {
	mmRemoveReservedItems.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockRemoveReservedItemsParams, len(mmRemoveReservedItems.callArgs))
	copy(argCopy, mmRemoveReservedItems.callArgs)

	mmRemoveReservedItems.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveReservedItemsDone returns true if the count of the RemoveReservedItems invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockRemoveReservedItemsDone() bool {
	if m.RemoveReservedItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveReservedItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveReservedItemsMock.invocationsDone()
}

// MinimockRemoveReservedItemsInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockRemoveReservedItemsInspect() {
	for _, e := range m.RemoveReservedItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.RemoveReservedItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveReservedItemsCounter := mm_atomic.LoadUint64(&m.afterRemoveReservedItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveReservedItemsMock.defaultExpectation != nil && afterRemoveReservedItemsCounter < 1 {
		if m.RemoveReservedItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.RemoveReservedItems at\n%s", m.RemoveReservedItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.RemoveReservedItems at\n%s with params: %#v", m.RemoveReservedItemsMock.defaultExpectation.expectationOrigins.origin, *m.RemoveReservedItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveReservedItems != nil && afterRemoveReservedItemsCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.RemoveReservedItems at\n%s", m.funcRemoveReservedItemsOrigin)
	}

	if !m.RemoveReservedItemsMock.invocationsDone() && afterRemoveReservedItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.RemoveReservedItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveReservedItemsMock.expectedInvocations), m.RemoveReservedItemsMock.expectedInvocationsOrigin, afterRemoveReservedItemsCounter)
	}
}

type mIStockRepositoryMockReserveItems struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockReserveItemsExpectation
	expectations       []*IStockRepositoryMockReserveItemsExpectation

	callArgs []*IStockRepositoryMockReserveItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockReserveItemsExpectation specifies expectation struct of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockReserveItemsParams
	paramPtrs          *IStockRepositoryMockReserveItemsParamPtrs
	expectationOrigins IStockRepositoryMockReserveItemsExpectationOrigins
	results            *IStockRepositoryMockReserveItemsResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockReserveItemsParams contains parameters of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsParams struct {
	ctx   context.Context
	tx    pgx.Tx
	items []models.Item
}

// IStockRepositoryMockReserveItemsParamPtrs contains pointers to parameters of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsParamPtrs struct {
	ctx   *context.Context
	tx    *pgx.Tx
	items *[]models.Item
}

// IStockRepositoryMockReserveItemsResults contains results of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsResults struct {
	err error
}

// IStockRepositoryMockReserveItemsOrigins contains origins of expectations of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsExpectationOrigins struct {
	origin      string
	originCtx   string
	originTx    string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveItems *mIStockRepositoryMockReserveItems) Optional() *mIStockRepositoryMockReserveItems {
	mmReserveItems.optional = true
	return mmReserveItems
}

// Expect sets up expected params for IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) Expect(ctx context.Context, tx pgx.Tx, items []models.Item) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{}
	}

	if mmReserveItems.defaultExpectation.paramPtrs != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by ExpectParams functions")
	}

	mmReserveItems.defaultExpectation.params = &IStockRepositoryMockReserveItemsParams{ctx, tx, items}
	mmReserveItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveItems.expectations {
		if minimock.Equal(e.params, mmReserveItems.defaultExpectation.params) {
			mmReserveItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveItems.defaultExpectation.params)
		}
	}

	return mmReserveItems
}

// ExpectCtxParam1 sets up expected param ctx for IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) ExpectCtxParam1(ctx context.Context) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{}
	}

	if mmReserveItems.defaultExpectation.params != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Expect")
	}

	if mmReserveItems.defaultExpectation.paramPtrs == nil {
		mmReserveItems.defaultExpectation.paramPtrs = &IStockRepositoryMockReserveItemsParamPtrs{}
	}
	mmReserveItems.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveItems.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveItems
}

// ExpectTxParam2 sets up expected param tx for IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) ExpectTxParam2(tx pgx.Tx) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{}
	}

	if mmReserveItems.defaultExpectation.params != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Expect")
	}

	if mmReserveItems.defaultExpectation.paramPtrs == nil {
		mmReserveItems.defaultExpectation.paramPtrs = &IStockRepositoryMockReserveItemsParamPtrs{}
	}
	mmReserveItems.defaultExpectation.paramPtrs.tx = &tx
	mmReserveItems.defaultExpectation.expectationOrigins.originTx = minimock.CallerInfo(1)

	return mmReserveItems
}

// ExpectItemsParam3 sets up expected param items for IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) ExpectItemsParam3(items []models.Item) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{}
	}

	if mmReserveItems.defaultExpectation.params != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Expect")
	}

	if mmReserveItems.defaultExpectation.paramPtrs == nil {
		mmReserveItems.defaultExpectation.paramPtrs = &IStockRepositoryMockReserveItemsParamPtrs{}
	}
	mmReserveItems.defaultExpectation.paramPtrs.items = &items
	mmReserveItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserveItems
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) Inspect(f func(ctx context.Context, tx pgx.Tx, items []models.Item)) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.inspectFuncReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.ReserveItems")
	}

	mmReserveItems.mock.inspectFuncReserveItems = f

	return mmReserveItems
}

// Return sets up results that will be returned by IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) Return(err error) *IStockRepositoryMock {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{mock: mmReserveItems.mock}
	}
	mmReserveItems.defaultExpectation.results = &IStockRepositoryMockReserveItemsResults{err}
	mmReserveItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveItems.mock
}

// Set uses given function f to mock the IStockRepository.ReserveItems method
func (mmReserveItems *mIStockRepositoryMockReserveItems) Set(f func(ctx context.Context, tx pgx.Tx, items []models.Item) (err error)) *IStockRepositoryMock {
	if mmReserveItems.defaultExpectation != nil {
		mmReserveItems.mock.t.Fatalf("Default expectation is already set for the IStockRepository.ReserveItems method")
	}

	if len(mmReserveItems.expectations) > 0 {
		mmReserveItems.mock.t.Fatalf("Some expectations are already set for the IStockRepository.ReserveItems method")
	}

	mmReserveItems.mock.funcReserveItems = f
	mmReserveItems.mock.funcReserveItemsOrigin = minimock.CallerInfo(1)
	return mmReserveItems.mock
}

// When sets expectation for the IStockRepository.ReserveItems which will trigger the result defined by the following
// Then helper
func (mmReserveItems *mIStockRepositoryMockReserveItems) When(ctx context.Context, tx pgx.Tx, items []models.Item) *IStockRepositoryMockReserveItemsExpectation {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	expectation := &IStockRepositoryMockReserveItemsExpectation{
		mock:               mmReserveItems.mock,
		params:             &IStockRepositoryMockReserveItemsParams{ctx, tx, items},
		expectationOrigins: IStockRepositoryMockReserveItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveItems.expectations = append(mmReserveItems.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.ReserveItems return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockReserveItemsExpectation) Then(err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockReserveItemsResults{err}
	return e.mock
}

// Times sets number of times IStockRepository.ReserveItems should be invoked
func (mmReserveItems *mIStockRepositoryMockReserveItems) Times(n uint64) *mIStockRepositoryMockReserveItems {
	if n == 0 {
		mmReserveItems.mock.t.Fatalf("Times of IStockRepositoryMock.ReserveItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveItems.expectedInvocations, n)
	mmReserveItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveItems
}

func (mmReserveItems *mIStockRepositoryMockReserveItems) invocationsDone() bool {
	if len(mmReserveItems.expectations) == 0 && mmReserveItems.defaultExpectation == nil && mmReserveItems.mock.funcReserveItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveItems.mock.afterReserveItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveItems implements mm_service.IStockRepository
func (mmReserveItems *IStockRepositoryMock) ReserveItems(ctx context.Context, tx pgx.Tx, items []models.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveItems.beforeReserveItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveItems.afterReserveItemsCounter, 1)

	mmReserveItems.t.Helper()

	if mmReserveItems.inspectFuncReserveItems != nil {
		mmReserveItems.inspectFuncReserveItems(ctx, tx, items)
	}

	mm_params := IStockRepositoryMockReserveItemsParams{ctx, tx, items}

	// Record call args
	mmReserveItems.ReserveItemsMock.mutex.Lock()
	mmReserveItems.ReserveItemsMock.callArgs = append(mmReserveItems.ReserveItemsMock.callArgs, &mm_params)
	mmReserveItems.ReserveItemsMock.mutex.Unlock()

	for _, e := range mmReserveItems.ReserveItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveItems.ReserveItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveItems.ReserveItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveItems.ReserveItemsMock.defaultExpectation.params
		mm_want_ptrs := mmReserveItems.ReserveItemsMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockReserveItemsParams{ctx, tx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveItems.t.Errorf("IStockRepositoryMock.ReserveItems got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveItems.ReserveItemsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tx != nil && !minimock.Equal(*mm_want_ptrs.tx, mm_got.tx) {
				mmReserveItems.t.Errorf("IStockRepositoryMock.ReserveItems got unexpected parameter tx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveItems.ReserveItemsMock.defaultExpectation.expectationOrigins.originTx, *mm_want_ptrs.tx, mm_got.tx, minimock.Diff(*mm_want_ptrs.tx, mm_got.tx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserveItems.t.Errorf("IStockRepositoryMock.ReserveItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveItems.ReserveItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveItems.t.Errorf("IStockRepositoryMock.ReserveItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveItems.ReserveItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveItems.ReserveItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveItems.t.Fatal("No results are set for the IStockRepositoryMock.ReserveItems")
		}
		return (*mm_results).err
	}
	if mmReserveItems.funcReserveItems != nil {
		return mmReserveItems.funcReserveItems(ctx, tx, items)
	}
	mmReserveItems.t.Fatalf("Unexpected call to IStockRepositoryMock.ReserveItems. %v %v %v", ctx, tx, items)
	return
}

// ReserveItemsAfterCounter returns a count of finished IStockRepositoryMock.ReserveItems invocations
func (mmReserveItems *IStockRepositoryMock) ReserveItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveItems.afterReserveItemsCounter)
}

// ReserveItemsBeforeCounter returns a count of IStockRepositoryMock.ReserveItems invocations
func (mmReserveItems *IStockRepositoryMock) ReserveItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveItems.beforeReserveItemsCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.ReserveItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveItems *mIStockRepositoryMockReserveItems) Calls() []*IStockRepositoryMockReserveItemsParams {
	mmReserveItems.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockReserveItemsParams, len(mmReserveItems.callArgs))
	copy(argCopy, mmReserveItems.callArgs)

	mmReserveItems.mutex.RUnlock()

	return argCopy
}

// MinimockReserveItemsDone returns true if the count of the ReserveItems invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockReserveItemsDone() bool {
	if m.ReserveItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveItemsMock.invocationsDone()
}

// MinimockReserveItemsInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockReserveItemsInspect() {
	for _, e := range m.ReserveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveItemsCounter := mm_atomic.LoadUint64(&m.afterReserveItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveItemsMock.defaultExpectation != nil && afterReserveItemsCounter < 1 {
		if m.ReserveItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s", m.ReserveItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s with params: %#v", m.ReserveItemsMock.defaultExpectation.expectationOrigins.origin, *m.ReserveItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveItems != nil && afterReserveItemsCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s", m.funcReserveItemsOrigin)
	}

	if !m.ReserveItemsMock.invocationsDone() && afterReserveItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.ReserveItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveItemsMock.expectedInvocations), m.ReserveItemsMock.expectedInvocationsOrigin, afterReserveItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCancelReservedItemsInspect()

			m.MinimockGetAvailableStockBySKUInspect()

			m.MinimockRemoveReservedItemsInspect()

			m.MinimockReserveItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelReservedItemsDone() &&
		m.MinimockGetAvailableStockBySKUDone() &&
		m.MinimockRemoveReservedItemsDone() &&
		m.MinimockReserveItemsDone()
}
