// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.IStockRepository -o stock_repository_mock.go -n IStockRepositoryMock -p mock

import (
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IStockRepositoryMock implements mm_service.IStockRepository
type IStockRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAvailableStockBySKU          func(SKU models.SKU) (u1 uint64, err error)
	funcGetAvailableStockBySKUOrigin    string
	inspectFuncGetAvailableStockBySKU   func(SKU models.SKU)
	afterGetAvailableStockBySKUCounter  uint64
	beforeGetAvailableStockBySKUCounter uint64
	GetAvailableStockBySKUMock          mIStockRepositoryMockGetAvailableStockBySKU

	funcReserveCancelItems          func(items []models.Item) (err error)
	funcReserveCancelItemsOrigin    string
	inspectFuncReserveCancelItems   func(items []models.Item)
	afterReserveCancelItemsCounter  uint64
	beforeReserveCancelItemsCounter uint64
	ReserveCancelItemsMock          mIStockRepositoryMockReserveCancelItems

	funcReserveItems          func(items []models.Item) (err error)
	funcReserveItemsOrigin    string
	inspectFuncReserveItems   func(items []models.Item)
	afterReserveItemsCounter  uint64
	beforeReserveItemsCounter uint64
	ReserveItemsMock          mIStockRepositoryMockReserveItems

	funcReserveRemoveItems          func(items []models.Item) (err error)
	funcReserveRemoveItemsOrigin    string
	inspectFuncReserveRemoveItems   func(items []models.Item)
	afterReserveRemoveItemsCounter  uint64
	beforeReserveRemoveItemsCounter uint64
	ReserveRemoveItemsMock          mIStockRepositoryMockReserveRemoveItems
}

// NewIStockRepositoryMock returns a mock for mm_service.IStockRepository
func NewIStockRepositoryMock(t minimock.Tester) *IStockRepositoryMock {
	m := &IStockRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAvailableStockBySKUMock = mIStockRepositoryMockGetAvailableStockBySKU{mock: m}
	m.GetAvailableStockBySKUMock.callArgs = []*IStockRepositoryMockGetAvailableStockBySKUParams{}

	m.ReserveCancelItemsMock = mIStockRepositoryMockReserveCancelItems{mock: m}
	m.ReserveCancelItemsMock.callArgs = []*IStockRepositoryMockReserveCancelItemsParams{}

	m.ReserveItemsMock = mIStockRepositoryMockReserveItems{mock: m}
	m.ReserveItemsMock.callArgs = []*IStockRepositoryMockReserveItemsParams{}

	m.ReserveRemoveItemsMock = mIStockRepositoryMockReserveRemoveItems{mock: m}
	m.ReserveRemoveItemsMock.callArgs = []*IStockRepositoryMockReserveRemoveItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIStockRepositoryMockGetAvailableStockBySKU struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockGetAvailableStockBySKUExpectation
	expectations       []*IStockRepositoryMockGetAvailableStockBySKUExpectation

	callArgs []*IStockRepositoryMockGetAvailableStockBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockGetAvailableStockBySKUExpectation specifies expectation struct of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockGetAvailableStockBySKUParams
	paramPtrs          *IStockRepositoryMockGetAvailableStockBySKUParamPtrs
	expectationOrigins IStockRepositoryMockGetAvailableStockBySKUExpectationOrigins
	results            *IStockRepositoryMockGetAvailableStockBySKUResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockGetAvailableStockBySKUParams contains parameters of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUParams struct {
	SKU models.SKU
}

// IStockRepositoryMockGetAvailableStockBySKUParamPtrs contains pointers to parameters of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUParamPtrs struct {
	SKU *models.SKU
}

// IStockRepositoryMockGetAvailableStockBySKUResults contains results of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUResults struct {
	u1  uint64
	err error
}

// IStockRepositoryMockGetAvailableStockBySKUOrigins contains origins of expectations of the IStockRepository.GetAvailableStockBySKU
type IStockRepositoryMockGetAvailableStockBySKUExpectationOrigins struct {
	origin    string
	originSKU string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Optional() *mIStockRepositoryMockGetAvailableStockBySKU {
	mmGetAvailableStockBySKU.optional = true
	return mmGetAvailableStockBySKU
}

// Expect sets up expected params for IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Expect(SKU models.SKU) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{}
	}

	if mmGetAvailableStockBySKU.defaultExpectation.paramPtrs != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by ExpectParams functions")
	}

	mmGetAvailableStockBySKU.defaultExpectation.params = &IStockRepositoryMockGetAvailableStockBySKUParams{SKU}
	mmGetAvailableStockBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAvailableStockBySKU.expectations {
		if minimock.Equal(e.params, mmGetAvailableStockBySKU.defaultExpectation.params) {
			mmGetAvailableStockBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAvailableStockBySKU.defaultExpectation.params)
		}
	}

	return mmGetAvailableStockBySKU
}

// ExpectSKUParam1 sets up expected param SKU for IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) ExpectSKUParam1(SKU models.SKU) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{}
	}

	if mmGetAvailableStockBySKU.defaultExpectation.params != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Expect")
	}

	if mmGetAvailableStockBySKU.defaultExpectation.paramPtrs == nil {
		mmGetAvailableStockBySKU.defaultExpectation.paramPtrs = &IStockRepositoryMockGetAvailableStockBySKUParamPtrs{}
	}
	mmGetAvailableStockBySKU.defaultExpectation.paramPtrs.SKU = &SKU
	mmGetAvailableStockBySKU.defaultExpectation.expectationOrigins.originSKU = minimock.CallerInfo(1)

	return mmGetAvailableStockBySKU
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Inspect(f func(SKU models.SKU)) *mIStockRepositoryMockGetAvailableStockBySKU {
	if mmGetAvailableStockBySKU.mock.inspectFuncGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.GetAvailableStockBySKU")
	}

	mmGetAvailableStockBySKU.mock.inspectFuncGetAvailableStockBySKU = f

	return mmGetAvailableStockBySKU
}

// Return sets up results that will be returned by IStockRepository.GetAvailableStockBySKU
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Return(u1 uint64, err error) *IStockRepositoryMock {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	if mmGetAvailableStockBySKU.defaultExpectation == nil {
		mmGetAvailableStockBySKU.defaultExpectation = &IStockRepositoryMockGetAvailableStockBySKUExpectation{mock: mmGetAvailableStockBySKU.mock}
	}
	mmGetAvailableStockBySKU.defaultExpectation.results = &IStockRepositoryMockGetAvailableStockBySKUResults{u1, err}
	mmGetAvailableStockBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAvailableStockBySKU.mock
}

// Set uses given function f to mock the IStockRepository.GetAvailableStockBySKU method
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Set(f func(SKU models.SKU) (u1 uint64, err error)) *IStockRepositoryMock {
	if mmGetAvailableStockBySKU.defaultExpectation != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Default expectation is already set for the IStockRepository.GetAvailableStockBySKU method")
	}

	if len(mmGetAvailableStockBySKU.expectations) > 0 {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Some expectations are already set for the IStockRepository.GetAvailableStockBySKU method")
	}

	mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU = f
	mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKUOrigin = minimock.CallerInfo(1)
	return mmGetAvailableStockBySKU.mock
}

// When sets expectation for the IStockRepository.GetAvailableStockBySKU which will trigger the result defined by the following
// Then helper
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) When(SKU models.SKU) *IStockRepositoryMockGetAvailableStockBySKUExpectation {
	if mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.mock.t.Fatalf("IStockRepositoryMock.GetAvailableStockBySKU mock is already set by Set")
	}

	expectation := &IStockRepositoryMockGetAvailableStockBySKUExpectation{
		mock:               mmGetAvailableStockBySKU.mock,
		params:             &IStockRepositoryMockGetAvailableStockBySKUParams{SKU},
		expectationOrigins: IStockRepositoryMockGetAvailableStockBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAvailableStockBySKU.expectations = append(mmGetAvailableStockBySKU.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.GetAvailableStockBySKU return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockGetAvailableStockBySKUExpectation) Then(u1 uint64, err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockGetAvailableStockBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times IStockRepository.GetAvailableStockBySKU should be invoked
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Times(n uint64) *mIStockRepositoryMockGetAvailableStockBySKU {
	if n == 0 {
		mmGetAvailableStockBySKU.mock.t.Fatalf("Times of IStockRepositoryMock.GetAvailableStockBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAvailableStockBySKU.expectedInvocations, n)
	mmGetAvailableStockBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAvailableStockBySKU
}

func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) invocationsDone() bool {
	if len(mmGetAvailableStockBySKU.expectations) == 0 && mmGetAvailableStockBySKU.defaultExpectation == nil && mmGetAvailableStockBySKU.mock.funcGetAvailableStockBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.mock.afterGetAvailableStockBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAvailableStockBySKU implements mm_service.IStockRepository
func (mmGetAvailableStockBySKU *IStockRepositoryMock) GetAvailableStockBySKU(SKU models.SKU) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmGetAvailableStockBySKU.beforeGetAvailableStockBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAvailableStockBySKU.afterGetAvailableStockBySKUCounter, 1)

	mmGetAvailableStockBySKU.t.Helper()

	if mmGetAvailableStockBySKU.inspectFuncGetAvailableStockBySKU != nil {
		mmGetAvailableStockBySKU.inspectFuncGetAvailableStockBySKU(SKU)
	}

	mm_params := IStockRepositoryMockGetAvailableStockBySKUParams{SKU}

	// Record call args
	mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.mutex.Lock()
	mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.callArgs = append(mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.callArgs, &mm_params)
	mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.mutex.Unlock()

	for _, e := range mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockGetAvailableStockBySKUParams{SKU}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.SKU != nil && !minimock.Equal(*mm_want_ptrs.SKU, mm_got.SKU) {
				mmGetAvailableStockBySKU.t.Errorf("IStockRepositoryMock.GetAvailableStockBySKU got unexpected parameter SKU, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.originSKU, *mm_want_ptrs.SKU, mm_got.SKU, minimock.Diff(*mm_want_ptrs.SKU, mm_got.SKU))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAvailableStockBySKU.t.Errorf("IStockRepositoryMock.GetAvailableStockBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAvailableStockBySKU.GetAvailableStockBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAvailableStockBySKU.t.Fatal("No results are set for the IStockRepositoryMock.GetAvailableStockBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetAvailableStockBySKU.funcGetAvailableStockBySKU != nil {
		return mmGetAvailableStockBySKU.funcGetAvailableStockBySKU(SKU)
	}
	mmGetAvailableStockBySKU.t.Fatalf("Unexpected call to IStockRepositoryMock.GetAvailableStockBySKU. %v", SKU)
	return
}

// GetAvailableStockBySKUAfterCounter returns a count of finished IStockRepositoryMock.GetAvailableStockBySKU invocations
func (mmGetAvailableStockBySKU *IStockRepositoryMock) GetAvailableStockBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.afterGetAvailableStockBySKUCounter)
}

// GetAvailableStockBySKUBeforeCounter returns a count of IStockRepositoryMock.GetAvailableStockBySKU invocations
func (mmGetAvailableStockBySKU *IStockRepositoryMock) GetAvailableStockBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAvailableStockBySKU.beforeGetAvailableStockBySKUCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.GetAvailableStockBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAvailableStockBySKU *mIStockRepositoryMockGetAvailableStockBySKU) Calls() []*IStockRepositoryMockGetAvailableStockBySKUParams {
	mmGetAvailableStockBySKU.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockGetAvailableStockBySKUParams, len(mmGetAvailableStockBySKU.callArgs))
	copy(argCopy, mmGetAvailableStockBySKU.callArgs)

	mmGetAvailableStockBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetAvailableStockBySKUDone returns true if the count of the GetAvailableStockBySKU invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockGetAvailableStockBySKUDone() bool {
	if m.GetAvailableStockBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAvailableStockBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAvailableStockBySKUMock.invocationsDone()
}

// MinimockGetAvailableStockBySKUInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockGetAvailableStockBySKUInspect() {
	for _, e := range m.GetAvailableStockBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAvailableStockBySKUCounter := mm_atomic.LoadUint64(&m.afterGetAvailableStockBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAvailableStockBySKUMock.defaultExpectation != nil && afterGetAvailableStockBySKUCounter < 1 {
		if m.GetAvailableStockBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s", m.GetAvailableStockBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s with params: %#v", m.GetAvailableStockBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetAvailableStockBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAvailableStockBySKU != nil && afterGetAvailableStockBySKUCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.GetAvailableStockBySKU at\n%s", m.funcGetAvailableStockBySKUOrigin)
	}

	if !m.GetAvailableStockBySKUMock.invocationsDone() && afterGetAvailableStockBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.GetAvailableStockBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAvailableStockBySKUMock.expectedInvocations), m.GetAvailableStockBySKUMock.expectedInvocationsOrigin, afterGetAvailableStockBySKUCounter)
	}
}

type mIStockRepositoryMockReserveCancelItems struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockReserveCancelItemsExpectation
	expectations       []*IStockRepositoryMockReserveCancelItemsExpectation

	callArgs []*IStockRepositoryMockReserveCancelItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockReserveCancelItemsExpectation specifies expectation struct of the IStockRepository.ReserveCancelItems
type IStockRepositoryMockReserveCancelItemsExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockReserveCancelItemsParams
	paramPtrs          *IStockRepositoryMockReserveCancelItemsParamPtrs
	expectationOrigins IStockRepositoryMockReserveCancelItemsExpectationOrigins
	results            *IStockRepositoryMockReserveCancelItemsResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockReserveCancelItemsParams contains parameters of the IStockRepository.ReserveCancelItems
type IStockRepositoryMockReserveCancelItemsParams struct {
	items []models.Item
}

// IStockRepositoryMockReserveCancelItemsParamPtrs contains pointers to parameters of the IStockRepository.ReserveCancelItems
type IStockRepositoryMockReserveCancelItemsParamPtrs struct {
	items *[]models.Item
}

// IStockRepositoryMockReserveCancelItemsResults contains results of the IStockRepository.ReserveCancelItems
type IStockRepositoryMockReserveCancelItemsResults struct {
	err error
}

// IStockRepositoryMockReserveCancelItemsOrigins contains origins of expectations of the IStockRepository.ReserveCancelItems
type IStockRepositoryMockReserveCancelItemsExpectationOrigins struct {
	origin      string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Optional() *mIStockRepositoryMockReserveCancelItems {
	mmReserveCancelItems.optional = true
	return mmReserveCancelItems
}

// Expect sets up expected params for IStockRepository.ReserveCancelItems
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Expect(items []models.Item) *mIStockRepositoryMockReserveCancelItems {
	if mmReserveCancelItems.mock.funcReserveCancelItems != nil {
		mmReserveCancelItems.mock.t.Fatalf("IStockRepositoryMock.ReserveCancelItems mock is already set by Set")
	}

	if mmReserveCancelItems.defaultExpectation == nil {
		mmReserveCancelItems.defaultExpectation = &IStockRepositoryMockReserveCancelItemsExpectation{}
	}

	if mmReserveCancelItems.defaultExpectation.paramPtrs != nil {
		mmReserveCancelItems.mock.t.Fatalf("IStockRepositoryMock.ReserveCancelItems mock is already set by ExpectParams functions")
	}

	mmReserveCancelItems.defaultExpectation.params = &IStockRepositoryMockReserveCancelItemsParams{items}
	mmReserveCancelItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveCancelItems.expectations {
		if minimock.Equal(e.params, mmReserveCancelItems.defaultExpectation.params) {
			mmReserveCancelItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancelItems.defaultExpectation.params)
		}
	}

	return mmReserveCancelItems
}

// ExpectItemsParam1 sets up expected param items for IStockRepository.ReserveCancelItems
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) ExpectItemsParam1(items []models.Item) *mIStockRepositoryMockReserveCancelItems {
	if mmReserveCancelItems.mock.funcReserveCancelItems != nil {
		mmReserveCancelItems.mock.t.Fatalf("IStockRepositoryMock.ReserveCancelItems mock is already set by Set")
	}

	if mmReserveCancelItems.defaultExpectation == nil {
		mmReserveCancelItems.defaultExpectation = &IStockRepositoryMockReserveCancelItemsExpectation{}
	}

	if mmReserveCancelItems.defaultExpectation.params != nil {
		mmReserveCancelItems.mock.t.Fatalf("IStockRepositoryMock.ReserveCancelItems mock is already set by Expect")
	}

	if mmReserveCancelItems.defaultExpectation.paramPtrs == nil {
		mmReserveCancelItems.defaultExpectation.paramPtrs = &IStockRepositoryMockReserveCancelItemsParamPtrs{}
	}
	mmReserveCancelItems.defaultExpectation.paramPtrs.items = &items
	mmReserveCancelItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserveCancelItems
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.ReserveCancelItems
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Inspect(f func(items []models.Item)) *mIStockRepositoryMockReserveCancelItems {
	if mmReserveCancelItems.mock.inspectFuncReserveCancelItems != nil {
		mmReserveCancelItems.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.ReserveCancelItems")
	}

	mmReserveCancelItems.mock.inspectFuncReserveCancelItems = f

	return mmReserveCancelItems
}

// Return sets up results that will be returned by IStockRepository.ReserveCancelItems
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Return(err error) *IStockRepositoryMock {
	if mmReserveCancelItems.mock.funcReserveCancelItems != nil {
		mmReserveCancelItems.mock.t.Fatalf("IStockRepositoryMock.ReserveCancelItems mock is already set by Set")
	}

	if mmReserveCancelItems.defaultExpectation == nil {
		mmReserveCancelItems.defaultExpectation = &IStockRepositoryMockReserveCancelItemsExpectation{mock: mmReserveCancelItems.mock}
	}
	mmReserveCancelItems.defaultExpectation.results = &IStockRepositoryMockReserveCancelItemsResults{err}
	mmReserveCancelItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveCancelItems.mock
}

// Set uses given function f to mock the IStockRepository.ReserveCancelItems method
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Set(f func(items []models.Item) (err error)) *IStockRepositoryMock {
	if mmReserveCancelItems.defaultExpectation != nil {
		mmReserveCancelItems.mock.t.Fatalf("Default expectation is already set for the IStockRepository.ReserveCancelItems method")
	}

	if len(mmReserveCancelItems.expectations) > 0 {
		mmReserveCancelItems.mock.t.Fatalf("Some expectations are already set for the IStockRepository.ReserveCancelItems method")
	}

	mmReserveCancelItems.mock.funcReserveCancelItems = f
	mmReserveCancelItems.mock.funcReserveCancelItemsOrigin = minimock.CallerInfo(1)
	return mmReserveCancelItems.mock
}

// When sets expectation for the IStockRepository.ReserveCancelItems which will trigger the result defined by the following
// Then helper
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) When(items []models.Item) *IStockRepositoryMockReserveCancelItemsExpectation {
	if mmReserveCancelItems.mock.funcReserveCancelItems != nil {
		mmReserveCancelItems.mock.t.Fatalf("IStockRepositoryMock.ReserveCancelItems mock is already set by Set")
	}

	expectation := &IStockRepositoryMockReserveCancelItemsExpectation{
		mock:               mmReserveCancelItems.mock,
		params:             &IStockRepositoryMockReserveCancelItemsParams{items},
		expectationOrigins: IStockRepositoryMockReserveCancelItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveCancelItems.expectations = append(mmReserveCancelItems.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.ReserveCancelItems return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockReserveCancelItemsExpectation) Then(err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockReserveCancelItemsResults{err}
	return e.mock
}

// Times sets number of times IStockRepository.ReserveCancelItems should be invoked
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Times(n uint64) *mIStockRepositoryMockReserveCancelItems {
	if n == 0 {
		mmReserveCancelItems.mock.t.Fatalf("Times of IStockRepositoryMock.ReserveCancelItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancelItems.expectedInvocations, n)
	mmReserveCancelItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveCancelItems
}

func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) invocationsDone() bool {
	if len(mmReserveCancelItems.expectations) == 0 && mmReserveCancelItems.defaultExpectation == nil && mmReserveCancelItems.mock.funcReserveCancelItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancelItems.mock.afterReserveCancelItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancelItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancelItems implements mm_service.IStockRepository
func (mmReserveCancelItems *IStockRepositoryMock) ReserveCancelItems(items []models.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveCancelItems.beforeReserveCancelItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancelItems.afterReserveCancelItemsCounter, 1)

	mmReserveCancelItems.t.Helper()

	if mmReserveCancelItems.inspectFuncReserveCancelItems != nil {
		mmReserveCancelItems.inspectFuncReserveCancelItems(items)
	}

	mm_params := IStockRepositoryMockReserveCancelItemsParams{items}

	// Record call args
	mmReserveCancelItems.ReserveCancelItemsMock.mutex.Lock()
	mmReserveCancelItems.ReserveCancelItemsMock.callArgs = append(mmReserveCancelItems.ReserveCancelItemsMock.callArgs, &mm_params)
	mmReserveCancelItems.ReserveCancelItemsMock.mutex.Unlock()

	for _, e := range mmReserveCancelItems.ReserveCancelItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockReserveCancelItemsParams{items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserveCancelItems.t.Errorf("IStockRepositoryMock.ReserveCancelItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancelItems.t.Errorf("IStockRepositoryMock.ReserveCancelItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancelItems.ReserveCancelItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancelItems.t.Fatal("No results are set for the IStockRepositoryMock.ReserveCancelItems")
		}
		return (*mm_results).err
	}
	if mmReserveCancelItems.funcReserveCancelItems != nil {
		return mmReserveCancelItems.funcReserveCancelItems(items)
	}
	mmReserveCancelItems.t.Fatalf("Unexpected call to IStockRepositoryMock.ReserveCancelItems. %v", items)
	return
}

// ReserveCancelItemsAfterCounter returns a count of finished IStockRepositoryMock.ReserveCancelItems invocations
func (mmReserveCancelItems *IStockRepositoryMock) ReserveCancelItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancelItems.afterReserveCancelItemsCounter)
}

// ReserveCancelItemsBeforeCounter returns a count of IStockRepositoryMock.ReserveCancelItems invocations
func (mmReserveCancelItems *IStockRepositoryMock) ReserveCancelItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancelItems.beforeReserveCancelItemsCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.ReserveCancelItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancelItems *mIStockRepositoryMockReserveCancelItems) Calls() []*IStockRepositoryMockReserveCancelItemsParams {
	mmReserveCancelItems.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockReserveCancelItemsParams, len(mmReserveCancelItems.callArgs))
	copy(argCopy, mmReserveCancelItems.callArgs)

	mmReserveCancelItems.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelItemsDone returns true if the count of the ReserveCancelItems invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockReserveCancelItemsDone() bool {
	if m.ReserveCancelItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelItemsMock.invocationsDone()
}

// MinimockReserveCancelItemsInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockReserveCancelItemsInspect() {
	for _, e := range m.ReserveCancelItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveCancelItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCancelItemsCounter := mm_atomic.LoadUint64(&m.afterReserveCancelItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelItemsMock.defaultExpectation != nil && afterReserveCancelItemsCounter < 1 {
		if m.ReserveCancelItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveCancelItems at\n%s", m.ReserveCancelItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveCancelItems at\n%s with params: %#v", m.ReserveCancelItemsMock.defaultExpectation.expectationOrigins.origin, *m.ReserveCancelItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancelItems != nil && afterReserveCancelItemsCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.ReserveCancelItems at\n%s", m.funcReserveCancelItemsOrigin)
	}

	if !m.ReserveCancelItemsMock.invocationsDone() && afterReserveCancelItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.ReserveCancelItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelItemsMock.expectedInvocations), m.ReserveCancelItemsMock.expectedInvocationsOrigin, afterReserveCancelItemsCounter)
	}
}

type mIStockRepositoryMockReserveItems struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockReserveItemsExpectation
	expectations       []*IStockRepositoryMockReserveItemsExpectation

	callArgs []*IStockRepositoryMockReserveItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockReserveItemsExpectation specifies expectation struct of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockReserveItemsParams
	paramPtrs          *IStockRepositoryMockReserveItemsParamPtrs
	expectationOrigins IStockRepositoryMockReserveItemsExpectationOrigins
	results            *IStockRepositoryMockReserveItemsResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockReserveItemsParams contains parameters of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsParams struct {
	items []models.Item
}

// IStockRepositoryMockReserveItemsParamPtrs contains pointers to parameters of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsParamPtrs struct {
	items *[]models.Item
}

// IStockRepositoryMockReserveItemsResults contains results of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsResults struct {
	err error
}

// IStockRepositoryMockReserveItemsOrigins contains origins of expectations of the IStockRepository.ReserveItems
type IStockRepositoryMockReserveItemsExpectationOrigins struct {
	origin      string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveItems *mIStockRepositoryMockReserveItems) Optional() *mIStockRepositoryMockReserveItems {
	mmReserveItems.optional = true
	return mmReserveItems
}

// Expect sets up expected params for IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) Expect(items []models.Item) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{}
	}

	if mmReserveItems.defaultExpectation.paramPtrs != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by ExpectParams functions")
	}

	mmReserveItems.defaultExpectation.params = &IStockRepositoryMockReserveItemsParams{items}
	mmReserveItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveItems.expectations {
		if minimock.Equal(e.params, mmReserveItems.defaultExpectation.params) {
			mmReserveItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveItems.defaultExpectation.params)
		}
	}

	return mmReserveItems
}

// ExpectItemsParam1 sets up expected param items for IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) ExpectItemsParam1(items []models.Item) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{}
	}

	if mmReserveItems.defaultExpectation.params != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Expect")
	}

	if mmReserveItems.defaultExpectation.paramPtrs == nil {
		mmReserveItems.defaultExpectation.paramPtrs = &IStockRepositoryMockReserveItemsParamPtrs{}
	}
	mmReserveItems.defaultExpectation.paramPtrs.items = &items
	mmReserveItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserveItems
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) Inspect(f func(items []models.Item)) *mIStockRepositoryMockReserveItems {
	if mmReserveItems.mock.inspectFuncReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.ReserveItems")
	}

	mmReserveItems.mock.inspectFuncReserveItems = f

	return mmReserveItems
}

// Return sets up results that will be returned by IStockRepository.ReserveItems
func (mmReserveItems *mIStockRepositoryMockReserveItems) Return(err error) *IStockRepositoryMock {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	if mmReserveItems.defaultExpectation == nil {
		mmReserveItems.defaultExpectation = &IStockRepositoryMockReserveItemsExpectation{mock: mmReserveItems.mock}
	}
	mmReserveItems.defaultExpectation.results = &IStockRepositoryMockReserveItemsResults{err}
	mmReserveItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveItems.mock
}

// Set uses given function f to mock the IStockRepository.ReserveItems method
func (mmReserveItems *mIStockRepositoryMockReserveItems) Set(f func(items []models.Item) (err error)) *IStockRepositoryMock {
	if mmReserveItems.defaultExpectation != nil {
		mmReserveItems.mock.t.Fatalf("Default expectation is already set for the IStockRepository.ReserveItems method")
	}

	if len(mmReserveItems.expectations) > 0 {
		mmReserveItems.mock.t.Fatalf("Some expectations are already set for the IStockRepository.ReserveItems method")
	}

	mmReserveItems.mock.funcReserveItems = f
	mmReserveItems.mock.funcReserveItemsOrigin = minimock.CallerInfo(1)
	return mmReserveItems.mock
}

// When sets expectation for the IStockRepository.ReserveItems which will trigger the result defined by the following
// Then helper
func (mmReserveItems *mIStockRepositoryMockReserveItems) When(items []models.Item) *IStockRepositoryMockReserveItemsExpectation {
	if mmReserveItems.mock.funcReserveItems != nil {
		mmReserveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveItems mock is already set by Set")
	}

	expectation := &IStockRepositoryMockReserveItemsExpectation{
		mock:               mmReserveItems.mock,
		params:             &IStockRepositoryMockReserveItemsParams{items},
		expectationOrigins: IStockRepositoryMockReserveItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveItems.expectations = append(mmReserveItems.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.ReserveItems return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockReserveItemsExpectation) Then(err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockReserveItemsResults{err}
	return e.mock
}

// Times sets number of times IStockRepository.ReserveItems should be invoked
func (mmReserveItems *mIStockRepositoryMockReserveItems) Times(n uint64) *mIStockRepositoryMockReserveItems {
	if n == 0 {
		mmReserveItems.mock.t.Fatalf("Times of IStockRepositoryMock.ReserveItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveItems.expectedInvocations, n)
	mmReserveItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveItems
}

func (mmReserveItems *mIStockRepositoryMockReserveItems) invocationsDone() bool {
	if len(mmReserveItems.expectations) == 0 && mmReserveItems.defaultExpectation == nil && mmReserveItems.mock.funcReserveItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveItems.mock.afterReserveItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveItems implements mm_service.IStockRepository
func (mmReserveItems *IStockRepositoryMock) ReserveItems(items []models.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveItems.beforeReserveItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveItems.afterReserveItemsCounter, 1)

	mmReserveItems.t.Helper()

	if mmReserveItems.inspectFuncReserveItems != nil {
		mmReserveItems.inspectFuncReserveItems(items)
	}

	mm_params := IStockRepositoryMockReserveItemsParams{items}

	// Record call args
	mmReserveItems.ReserveItemsMock.mutex.Lock()
	mmReserveItems.ReserveItemsMock.callArgs = append(mmReserveItems.ReserveItemsMock.callArgs, &mm_params)
	mmReserveItems.ReserveItemsMock.mutex.Unlock()

	for _, e := range mmReserveItems.ReserveItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveItems.ReserveItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveItems.ReserveItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveItems.ReserveItemsMock.defaultExpectation.params
		mm_want_ptrs := mmReserveItems.ReserveItemsMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockReserveItemsParams{items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserveItems.t.Errorf("IStockRepositoryMock.ReserveItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveItems.ReserveItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveItems.t.Errorf("IStockRepositoryMock.ReserveItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveItems.ReserveItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveItems.ReserveItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveItems.t.Fatal("No results are set for the IStockRepositoryMock.ReserveItems")
		}
		return (*mm_results).err
	}
	if mmReserveItems.funcReserveItems != nil {
		return mmReserveItems.funcReserveItems(items)
	}
	mmReserveItems.t.Fatalf("Unexpected call to IStockRepositoryMock.ReserveItems. %v", items)
	return
}

// ReserveItemsAfterCounter returns a count of finished IStockRepositoryMock.ReserveItems invocations
func (mmReserveItems *IStockRepositoryMock) ReserveItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveItems.afterReserveItemsCounter)
}

// ReserveItemsBeforeCounter returns a count of IStockRepositoryMock.ReserveItems invocations
func (mmReserveItems *IStockRepositoryMock) ReserveItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveItems.beforeReserveItemsCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.ReserveItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveItems *mIStockRepositoryMockReserveItems) Calls() []*IStockRepositoryMockReserveItemsParams {
	mmReserveItems.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockReserveItemsParams, len(mmReserveItems.callArgs))
	copy(argCopy, mmReserveItems.callArgs)

	mmReserveItems.mutex.RUnlock()

	return argCopy
}

// MinimockReserveItemsDone returns true if the count of the ReserveItems invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockReserveItemsDone() bool {
	if m.ReserveItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveItemsMock.invocationsDone()
}

// MinimockReserveItemsInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockReserveItemsInspect() {
	for _, e := range m.ReserveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveItemsCounter := mm_atomic.LoadUint64(&m.afterReserveItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveItemsMock.defaultExpectation != nil && afterReserveItemsCounter < 1 {
		if m.ReserveItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s", m.ReserveItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s with params: %#v", m.ReserveItemsMock.defaultExpectation.expectationOrigins.origin, *m.ReserveItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveItems != nil && afterReserveItemsCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.ReserveItems at\n%s", m.funcReserveItemsOrigin)
	}

	if !m.ReserveItemsMock.invocationsDone() && afterReserveItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.ReserveItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveItemsMock.expectedInvocations), m.ReserveItemsMock.expectedInvocationsOrigin, afterReserveItemsCounter)
	}
}

type mIStockRepositoryMockReserveRemoveItems struct {
	optional           bool
	mock               *IStockRepositoryMock
	defaultExpectation *IStockRepositoryMockReserveRemoveItemsExpectation
	expectations       []*IStockRepositoryMockReserveRemoveItemsExpectation

	callArgs []*IStockRepositoryMockReserveRemoveItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IStockRepositoryMockReserveRemoveItemsExpectation specifies expectation struct of the IStockRepository.ReserveRemoveItems
type IStockRepositoryMockReserveRemoveItemsExpectation struct {
	mock               *IStockRepositoryMock
	params             *IStockRepositoryMockReserveRemoveItemsParams
	paramPtrs          *IStockRepositoryMockReserveRemoveItemsParamPtrs
	expectationOrigins IStockRepositoryMockReserveRemoveItemsExpectationOrigins
	results            *IStockRepositoryMockReserveRemoveItemsResults
	returnOrigin       string
	Counter            uint64
}

// IStockRepositoryMockReserveRemoveItemsParams contains parameters of the IStockRepository.ReserveRemoveItems
type IStockRepositoryMockReserveRemoveItemsParams struct {
	items []models.Item
}

// IStockRepositoryMockReserveRemoveItemsParamPtrs contains pointers to parameters of the IStockRepository.ReserveRemoveItems
type IStockRepositoryMockReserveRemoveItemsParamPtrs struct {
	items *[]models.Item
}

// IStockRepositoryMockReserveRemoveItemsResults contains results of the IStockRepository.ReserveRemoveItems
type IStockRepositoryMockReserveRemoveItemsResults struct {
	err error
}

// IStockRepositoryMockReserveRemoveItemsOrigins contains origins of expectations of the IStockRepository.ReserveRemoveItems
type IStockRepositoryMockReserveRemoveItemsExpectationOrigins struct {
	origin      string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Optional() *mIStockRepositoryMockReserveRemoveItems {
	mmReserveRemoveItems.optional = true
	return mmReserveRemoveItems
}

// Expect sets up expected params for IStockRepository.ReserveRemoveItems
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Expect(items []models.Item) *mIStockRepositoryMockReserveRemoveItems {
	if mmReserveRemoveItems.mock.funcReserveRemoveItems != nil {
		mmReserveRemoveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveRemoveItems mock is already set by Set")
	}

	if mmReserveRemoveItems.defaultExpectation == nil {
		mmReserveRemoveItems.defaultExpectation = &IStockRepositoryMockReserveRemoveItemsExpectation{}
	}

	if mmReserveRemoveItems.defaultExpectation.paramPtrs != nil {
		mmReserveRemoveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveRemoveItems mock is already set by ExpectParams functions")
	}

	mmReserveRemoveItems.defaultExpectation.params = &IStockRepositoryMockReserveRemoveItemsParams{items}
	mmReserveRemoveItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemoveItems.expectations {
		if minimock.Equal(e.params, mmReserveRemoveItems.defaultExpectation.params) {
			mmReserveRemoveItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemoveItems.defaultExpectation.params)
		}
	}

	return mmReserveRemoveItems
}

// ExpectItemsParam1 sets up expected param items for IStockRepository.ReserveRemoveItems
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) ExpectItemsParam1(items []models.Item) *mIStockRepositoryMockReserveRemoveItems {
	if mmReserveRemoveItems.mock.funcReserveRemoveItems != nil {
		mmReserveRemoveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveRemoveItems mock is already set by Set")
	}

	if mmReserveRemoveItems.defaultExpectation == nil {
		mmReserveRemoveItems.defaultExpectation = &IStockRepositoryMockReserveRemoveItemsExpectation{}
	}

	if mmReserveRemoveItems.defaultExpectation.params != nil {
		mmReserveRemoveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveRemoveItems mock is already set by Expect")
	}

	if mmReserveRemoveItems.defaultExpectation.paramPtrs == nil {
		mmReserveRemoveItems.defaultExpectation.paramPtrs = &IStockRepositoryMockReserveRemoveItemsParamPtrs{}
	}
	mmReserveRemoveItems.defaultExpectation.paramPtrs.items = &items
	mmReserveRemoveItems.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserveRemoveItems
}

// Inspect accepts an inspector function that has same arguments as the IStockRepository.ReserveRemoveItems
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Inspect(f func(items []models.Item)) *mIStockRepositoryMockReserveRemoveItems {
	if mmReserveRemoveItems.mock.inspectFuncReserveRemoveItems != nil {
		mmReserveRemoveItems.mock.t.Fatalf("Inspect function is already set for IStockRepositoryMock.ReserveRemoveItems")
	}

	mmReserveRemoveItems.mock.inspectFuncReserveRemoveItems = f

	return mmReserveRemoveItems
}

// Return sets up results that will be returned by IStockRepository.ReserveRemoveItems
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Return(err error) *IStockRepositoryMock {
	if mmReserveRemoveItems.mock.funcReserveRemoveItems != nil {
		mmReserveRemoveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveRemoveItems mock is already set by Set")
	}

	if mmReserveRemoveItems.defaultExpectation == nil {
		mmReserveRemoveItems.defaultExpectation = &IStockRepositoryMockReserveRemoveItemsExpectation{mock: mmReserveRemoveItems.mock}
	}
	mmReserveRemoveItems.defaultExpectation.results = &IStockRepositoryMockReserveRemoveItemsResults{err}
	mmReserveRemoveItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemoveItems.mock
}

// Set uses given function f to mock the IStockRepository.ReserveRemoveItems method
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Set(f func(items []models.Item) (err error)) *IStockRepositoryMock {
	if mmReserveRemoveItems.defaultExpectation != nil {
		mmReserveRemoveItems.mock.t.Fatalf("Default expectation is already set for the IStockRepository.ReserveRemoveItems method")
	}

	if len(mmReserveRemoveItems.expectations) > 0 {
		mmReserveRemoveItems.mock.t.Fatalf("Some expectations are already set for the IStockRepository.ReserveRemoveItems method")
	}

	mmReserveRemoveItems.mock.funcReserveRemoveItems = f
	mmReserveRemoveItems.mock.funcReserveRemoveItemsOrigin = minimock.CallerInfo(1)
	return mmReserveRemoveItems.mock
}

// When sets expectation for the IStockRepository.ReserveRemoveItems which will trigger the result defined by the following
// Then helper
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) When(items []models.Item) *IStockRepositoryMockReserveRemoveItemsExpectation {
	if mmReserveRemoveItems.mock.funcReserveRemoveItems != nil {
		mmReserveRemoveItems.mock.t.Fatalf("IStockRepositoryMock.ReserveRemoveItems mock is already set by Set")
	}

	expectation := &IStockRepositoryMockReserveRemoveItemsExpectation{
		mock:               mmReserveRemoveItems.mock,
		params:             &IStockRepositoryMockReserveRemoveItemsParams{items},
		expectationOrigins: IStockRepositoryMockReserveRemoveItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemoveItems.expectations = append(mmReserveRemoveItems.expectations, expectation)
	return expectation
}

// Then sets up IStockRepository.ReserveRemoveItems return parameters for the expectation previously defined by the When method
func (e *IStockRepositoryMockReserveRemoveItemsExpectation) Then(err error) *IStockRepositoryMock {
	e.results = &IStockRepositoryMockReserveRemoveItemsResults{err}
	return e.mock
}

// Times sets number of times IStockRepository.ReserveRemoveItems should be invoked
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Times(n uint64) *mIStockRepositoryMockReserveRemoveItems {
	if n == 0 {
		mmReserveRemoveItems.mock.t.Fatalf("Times of IStockRepositoryMock.ReserveRemoveItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemoveItems.expectedInvocations, n)
	mmReserveRemoveItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemoveItems
}

func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) invocationsDone() bool {
	if len(mmReserveRemoveItems.expectations) == 0 && mmReserveRemoveItems.defaultExpectation == nil && mmReserveRemoveItems.mock.funcReserveRemoveItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemoveItems.mock.afterReserveRemoveItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemoveItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemoveItems implements mm_service.IStockRepository
func (mmReserveRemoveItems *IStockRepositoryMock) ReserveRemoveItems(items []models.Item) (err error) {
	mm_atomic.AddUint64(&mmReserveRemoveItems.beforeReserveRemoveItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemoveItems.afterReserveRemoveItemsCounter, 1)

	mmReserveRemoveItems.t.Helper()

	if mmReserveRemoveItems.inspectFuncReserveRemoveItems != nil {
		mmReserveRemoveItems.inspectFuncReserveRemoveItems(items)
	}

	mm_params := IStockRepositoryMockReserveRemoveItemsParams{items}

	// Record call args
	mmReserveRemoveItems.ReserveRemoveItemsMock.mutex.Lock()
	mmReserveRemoveItems.ReserveRemoveItemsMock.callArgs = append(mmReserveRemoveItems.ReserveRemoveItemsMock.callArgs, &mm_params)
	mmReserveRemoveItems.ReserveRemoveItemsMock.mutex.Unlock()

	for _, e := range mmReserveRemoveItems.ReserveRemoveItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation.paramPtrs

		mm_got := IStockRepositoryMockReserveRemoveItemsParams{items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserveRemoveItems.t.Errorf("IStockRepositoryMock.ReserveRemoveItems got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemoveItems.t.Errorf("IStockRepositoryMock.ReserveRemoveItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemoveItems.ReserveRemoveItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemoveItems.t.Fatal("No results are set for the IStockRepositoryMock.ReserveRemoveItems")
		}
		return (*mm_results).err
	}
	if mmReserveRemoveItems.funcReserveRemoveItems != nil {
		return mmReserveRemoveItems.funcReserveRemoveItems(items)
	}
	mmReserveRemoveItems.t.Fatalf("Unexpected call to IStockRepositoryMock.ReserveRemoveItems. %v", items)
	return
}

// ReserveRemoveItemsAfterCounter returns a count of finished IStockRepositoryMock.ReserveRemoveItems invocations
func (mmReserveRemoveItems *IStockRepositoryMock) ReserveRemoveItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemoveItems.afterReserveRemoveItemsCounter)
}

// ReserveRemoveItemsBeforeCounter returns a count of IStockRepositoryMock.ReserveRemoveItems invocations
func (mmReserveRemoveItems *IStockRepositoryMock) ReserveRemoveItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemoveItems.beforeReserveRemoveItemsCounter)
}

// Calls returns a list of arguments used in each call to IStockRepositoryMock.ReserveRemoveItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemoveItems *mIStockRepositoryMockReserveRemoveItems) Calls() []*IStockRepositoryMockReserveRemoveItemsParams {
	mmReserveRemoveItems.mutex.RLock()

	argCopy := make([]*IStockRepositoryMockReserveRemoveItemsParams, len(mmReserveRemoveItems.callArgs))
	copy(argCopy, mmReserveRemoveItems.callArgs)

	mmReserveRemoveItems.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveItemsDone returns true if the count of the ReserveRemoveItems invocations corresponds
// the number of defined expectations
func (m *IStockRepositoryMock) MinimockReserveRemoveItemsDone() bool {
	if m.ReserveRemoveItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveItemsMock.invocationsDone()
}

// MinimockReserveRemoveItemsInspect logs each unmet expectation
func (m *IStockRepositoryMock) MinimockReserveRemoveItemsInspect() {
	for _, e := range m.ReserveRemoveItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveRemoveItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveItemsCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveItemsMock.defaultExpectation != nil && afterReserveRemoveItemsCounter < 1 {
		if m.ReserveRemoveItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveRemoveItems at\n%s", m.ReserveRemoveItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IStockRepositoryMock.ReserveRemoveItems at\n%s with params: %#v", m.ReserveRemoveItemsMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemoveItems != nil && afterReserveRemoveItemsCounter < 1 {
		m.t.Errorf("Expected call to IStockRepositoryMock.ReserveRemoveItems at\n%s", m.funcReserveRemoveItemsOrigin)
	}

	if !m.ReserveRemoveItemsMock.invocationsDone() && afterReserveRemoveItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to IStockRepositoryMock.ReserveRemoveItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveItemsMock.expectedInvocations), m.ReserveRemoveItemsMock.expectedInvocationsOrigin, afterReserveRemoveItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IStockRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAvailableStockBySKUInspect()

			m.MinimockReserveCancelItemsInspect()

			m.MinimockReserveItemsInspect()

			m.MinimockReserveRemoveItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IStockRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IStockRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAvailableStockBySKUDone() &&
		m.MinimockReserveCancelItemsDone() &&
		m.MinimockReserveItemsDone() &&
		m.MinimockReserveRemoveItemsDone()
}
