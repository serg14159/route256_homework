// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/jackc/pgx/v5.Tx -o pgx_mock.go -n TxMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_pgx "github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// TxMock implements mm_pgx.Tx
type TxMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func(ctx context.Context) (t1 mm_pgx.Tx, err error)
	funcBeginOrigin    string
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mTxMockBegin

	funcCommit          func(ctx context.Context) (err error)
	funcCommitOrigin    string
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mTxMockCommit

	funcConn          func() (cp1 *mm_pgx.Conn)
	funcConnOrigin    string
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mTxMockConn

	funcCopyFrom          func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)
	funcCopyFromOrigin    string
	inspectFuncCopyFrom   func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mTxMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)
	funcExecOrigin    string
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...any)
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mTxMockExec

	funcLargeObjects          func() (l1 mm_pgx.LargeObjects)
	funcLargeObjectsOrigin    string
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mTxMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	funcPrepareOrigin    string
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mTxMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Rows, err error)
	funcQueryOrigin    string
	inspectFuncQuery   func(ctx context.Context, sql string, args ...any)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mTxMockQuery

	funcQueryRow          func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Row)
	funcQueryRowOrigin    string
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...any)
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mTxMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	funcRollbackOrigin    string
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mTxMockRollback

	funcSendBatch          func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)
	funcSendBatchOrigin    string
	inspectFuncSendBatch   func(ctx context.Context, b *mm_pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mTxMockSendBatch
}

// NewTxMock returns a mock for mm_pgx.Tx
func NewTxMock(t minimock.Tester) *TxMock {
	m := &TxMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mTxMockBegin{mock: m}
	m.BeginMock.callArgs = []*TxMockBeginParams{}

	m.CommitMock = mTxMockCommit{mock: m}
	m.CommitMock.callArgs = []*TxMockCommitParams{}

	m.ConnMock = mTxMockConn{mock: m}

	m.CopyFromMock = mTxMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*TxMockCopyFromParams{}

	m.ExecMock = mTxMockExec{mock: m}
	m.ExecMock.callArgs = []*TxMockExecParams{}

	m.LargeObjectsMock = mTxMockLargeObjects{mock: m}

	m.PrepareMock = mTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*TxMockPrepareParams{}

	m.QueryMock = mTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*TxMockQueryParams{}

	m.QueryRowMock = mTxMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*TxMockQueryRowParams{}

	m.RollbackMock = mTxMockRollback{mock: m}
	m.RollbackMock.callArgs = []*TxMockRollbackParams{}

	m.SendBatchMock = mTxMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*TxMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTxMockBegin struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockBeginExpectation
	expectations       []*TxMockBeginExpectation

	callArgs []*TxMockBeginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockBeginExpectation specifies expectation struct of the Tx.Begin
type TxMockBeginExpectation struct {
	mock               *TxMock
	params             *TxMockBeginParams
	paramPtrs          *TxMockBeginParamPtrs
	expectationOrigins TxMockBeginExpectationOrigins
	results            *TxMockBeginResults
	returnOrigin       string
	Counter            uint64
}

// TxMockBeginParams contains parameters of the Tx.Begin
type TxMockBeginParams struct {
	ctx context.Context
}

// TxMockBeginParamPtrs contains pointers to parameters of the Tx.Begin
type TxMockBeginParamPtrs struct {
	ctx *context.Context
}

// TxMockBeginResults contains results of the Tx.Begin
type TxMockBeginResults struct {
	t1  mm_pgx.Tx
	err error
}

// TxMockBeginOrigins contains origins of expectations of the Tx.Begin
type TxMockBeginExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBegin *mTxMockBegin) Optional() *mTxMockBegin {
	mmBegin.optional = true
	return mmBegin
}

// Expect sets up expected params for Tx.Begin
func (mmBegin *mTxMockBegin) Expect(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.paramPtrs != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by ExpectParams functions")
	}

	mmBegin.defaultExpectation.params = &TxMockBeginParams{ctx}
	mmBegin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Begin
func (mmBegin *mTxMockBegin) ExpectCtxParam1(ctx context.Context) *mTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{}
	}

	if mmBegin.defaultExpectation.params != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Expect")
	}

	if mmBegin.defaultExpectation.paramPtrs == nil {
		mmBegin.defaultExpectation.paramPtrs = &TxMockBeginParamPtrs{}
	}
	mmBegin.defaultExpectation.paramPtrs.ctx = &ctx
	mmBegin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the Tx.Begin
func (mmBegin *mTxMockBegin) Inspect(f func(ctx context.Context)) *mTxMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for TxMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by Tx.Begin
func (mmBegin *mTxMockBegin) Return(t1 mm_pgx.Tx, err error) *TxMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &TxMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &TxMockBeginResults{t1, err}
	mmBegin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// Set uses given function f to mock the Tx.Begin method
func (mmBegin *mTxMockBegin) Set(f func(ctx context.Context) (t1 mm_pgx.Tx, err error)) *TxMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the Tx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the Tx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	mmBegin.mock.funcBeginOrigin = minimock.CallerInfo(1)
	return mmBegin.mock
}

// When sets expectation for the Tx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mTxMockBegin) When(ctx context.Context) *TxMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("TxMock.Begin mock is already set by Set")
	}

	expectation := &TxMockBeginExpectation{
		mock:               mmBegin.mock,
		params:             &TxMockBeginParams{ctx},
		expectationOrigins: TxMockBeginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up Tx.Begin return parameters for the expectation previously defined by the When method
func (e *TxMockBeginExpectation) Then(t1 mm_pgx.Tx, err error) *TxMock {
	e.results = &TxMockBeginResults{t1, err}
	return e.mock
}

// Times sets number of times Tx.Begin should be invoked
func (mmBegin *mTxMockBegin) Times(n uint64) *mTxMockBegin {
	if n == 0 {
		mmBegin.mock.t.Fatalf("Times of TxMock.Begin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBegin.expectedInvocations, n)
	mmBegin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBegin
}

func (mmBegin *mTxMockBegin) invocationsDone() bool {
	if len(mmBegin.expectations) == 0 && mmBegin.defaultExpectation == nil && mmBegin.mock.funcBegin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBegin.mock.afterBeginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBegin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Begin implements mm_pgx.Tx
func (mmBegin *TxMock) Begin(ctx context.Context) (t1 mm_pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	mmBegin.t.Helper()

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := TxMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, &mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_want_ptrs := mmBegin.BeginMock.defaultExpectation.paramPtrs

		mm_got := TxMockBeginParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmBegin.t.Errorf("TxMock.Begin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmBegin.BeginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("TxMock.Begin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmBegin.BeginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the TxMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to TxMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished TxMock.Begin invocations
func (mmBegin *TxMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of TxMock.Begin invocations
func (mmBegin *TxMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mTxMockBegin) Calls() []*TxMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*TxMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockBeginDone() bool {
	if m.BeginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginMock.invocationsDone()
}

// MinimockBeginInspect logs each unmet expectation
func (m *TxMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Begin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterBeginCounter := mm_atomic.LoadUint64(&m.afterBeginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && afterBeginCounter < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.Begin at\n%s", m.BeginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.Begin at\n%s with params: %#v", m.BeginMock.defaultExpectation.expectationOrigins.origin, *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && afterBeginCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Begin at\n%s", m.funcBeginOrigin)
	}

	if !m.BeginMock.invocationsDone() && afterBeginCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Begin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginMock.expectedInvocations), m.BeginMock.expectedInvocationsOrigin, afterBeginCounter)
	}
}

type mTxMockCommit struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockCommitExpectation
	expectations       []*TxMockCommitExpectation

	callArgs []*TxMockCommitParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockCommitExpectation specifies expectation struct of the Tx.Commit
type TxMockCommitExpectation struct {
	mock               *TxMock
	params             *TxMockCommitParams
	paramPtrs          *TxMockCommitParamPtrs
	expectationOrigins TxMockCommitExpectationOrigins
	results            *TxMockCommitResults
	returnOrigin       string
	Counter            uint64
}

// TxMockCommitParams contains parameters of the Tx.Commit
type TxMockCommitParams struct {
	ctx context.Context
}

// TxMockCommitParamPtrs contains pointers to parameters of the Tx.Commit
type TxMockCommitParamPtrs struct {
	ctx *context.Context
}

// TxMockCommitResults contains results of the Tx.Commit
type TxMockCommitResults struct {
	err error
}

// TxMockCommitOrigins contains origins of expectations of the Tx.Commit
type TxMockCommitExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommit *mTxMockCommit) Optional() *mTxMockCommit {
	mmCommit.optional = true
	return mmCommit
}

// Expect sets up expected params for Tx.Commit
func (mmCommit *mTxMockCommit) Expect(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.paramPtrs != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by ExpectParams functions")
	}

	mmCommit.defaultExpectation.params = &TxMockCommitParams{ctx}
	mmCommit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Commit
func (mmCommit *mTxMockCommit) ExpectCtxParam1(ctx context.Context) *mTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{}
	}

	if mmCommit.defaultExpectation.params != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Expect")
	}

	if mmCommit.defaultExpectation.paramPtrs == nil {
		mmCommit.defaultExpectation.paramPtrs = &TxMockCommitParamPtrs{}
	}
	mmCommit.defaultExpectation.paramPtrs.ctx = &ctx
	mmCommit.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the Tx.Commit
func (mmCommit *mTxMockCommit) Inspect(f func(ctx context.Context)) *mTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for TxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by Tx.Commit
func (mmCommit *mTxMockCommit) Return(err error) *TxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &TxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &TxMockCommitResults{err}
	mmCommit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// Set uses given function f to mock the Tx.Commit method
func (mmCommit *mTxMockCommit) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the Tx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the Tx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	mmCommit.mock.funcCommitOrigin = minimock.CallerInfo(1)
	return mmCommit.mock
}

// When sets expectation for the Tx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mTxMockCommit) When(ctx context.Context) *TxMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("TxMock.Commit mock is already set by Set")
	}

	expectation := &TxMockCommitExpectation{
		mock:               mmCommit.mock,
		params:             &TxMockCommitParams{ctx},
		expectationOrigins: TxMockCommitExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up Tx.Commit return parameters for the expectation previously defined by the When method
func (e *TxMockCommitExpectation) Then(err error) *TxMock {
	e.results = &TxMockCommitResults{err}
	return e.mock
}

// Times sets number of times Tx.Commit should be invoked
func (mmCommit *mTxMockCommit) Times(n uint64) *mTxMockCommit {
	if n == 0 {
		mmCommit.mock.t.Fatalf("Times of TxMock.Commit mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommit.expectedInvocations, n)
	mmCommit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommit
}

func (mmCommit *mTxMockCommit) invocationsDone() bool {
	if len(mmCommit.expectations) == 0 && mmCommit.defaultExpectation == nil && mmCommit.mock.funcCommit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommit.mock.afterCommitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Commit implements mm_pgx.Tx
func (mmCommit *TxMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	mmCommit.t.Helper()

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := TxMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, &mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_want_ptrs := mmCommit.CommitMock.defaultExpectation.paramPtrs

		mm_got := TxMockCommitParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCommit.t.Errorf("TxMock.Commit got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCommit.CommitMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("TxMock.Commit got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCommit.CommitMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the TxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to TxMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished TxMock.Commit invocations
func (mmCommit *TxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of TxMock.Commit invocations
func (mmCommit *TxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mTxMockCommit) Calls() []*TxMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*TxMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCommitDone() bool {
	if m.CommitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitMock.invocationsDone()
}

// MinimockCommitInspect logs each unmet expectation
func (m *TxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Commit at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCommitCounter := mm_atomic.LoadUint64(&m.afterCommitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && afterCommitCounter < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.Commit at\n%s", m.CommitMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.Commit at\n%s with params: %#v", m.CommitMock.defaultExpectation.expectationOrigins.origin, *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && afterCommitCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Commit at\n%s", m.funcCommitOrigin)
	}

	if !m.CommitMock.invocationsDone() && afterCommitCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Commit at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitMock.expectedInvocations), m.CommitMock.expectedInvocationsOrigin, afterCommitCounter)
	}
}

type mTxMockConn struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockConnExpectation
	expectations       []*TxMockConnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockConnExpectation specifies expectation struct of the Tx.Conn
type TxMockConnExpectation struct {
	mock *TxMock

	results      *TxMockConnResults
	returnOrigin string
	Counter      uint64
}

// TxMockConnResults contains results of the Tx.Conn
type TxMockConnResults struct {
	cp1 *mm_pgx.Conn
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmConn *mTxMockConn) Optional() *mTxMockConn {
	mmConn.optional = true
	return mmConn
}

// Expect sets up expected params for Tx.Conn
func (mmConn *mTxMockConn) Expect() *mTxMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the Tx.Conn
func (mmConn *mTxMockConn) Inspect(f func()) *mTxMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for TxMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by Tx.Conn
func (mmConn *mTxMockConn) Return(cp1 *mm_pgx.Conn) *TxMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("TxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &TxMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &TxMockConnResults{cp1}
	mmConn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmConn.mock
}

// Set uses given function f to mock the Tx.Conn method
func (mmConn *mTxMockConn) Set(f func() (cp1 *mm_pgx.Conn)) *TxMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the Tx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the Tx.Conn method")
	}

	mmConn.mock.funcConn = f
	mmConn.mock.funcConnOrigin = minimock.CallerInfo(1)
	return mmConn.mock
}

// Times sets number of times Tx.Conn should be invoked
func (mmConn *mTxMockConn) Times(n uint64) *mTxMockConn {
	if n == 0 {
		mmConn.mock.t.Fatalf("Times of TxMock.Conn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmConn.expectedInvocations, n)
	mmConn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmConn
}

func (mmConn *mTxMockConn) invocationsDone() bool {
	if len(mmConn.expectations) == 0 && mmConn.defaultExpectation == nil && mmConn.mock.funcConn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmConn.mock.afterConnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmConn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Conn implements mm_pgx.Tx
func (mmConn *TxMock) Conn() (cp1 *mm_pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	mmConn.t.Helper()

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the TxMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to TxMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished TxMock.Conn invocations
func (mmConn *TxMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of TxMock.Conn invocations
func (mmConn *TxMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockConnDone() bool {
	if m.ConnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ConnMock.invocationsDone()
}

// MinimockConnInspect logs each unmet expectation
func (m *TxMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.Conn")
		}
	}

	afterConnCounter := mm_atomic.LoadUint64(&m.afterConnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && afterConnCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Conn at\n%s", m.ConnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && afterConnCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Conn at\n%s", m.funcConnOrigin)
	}

	if !m.ConnMock.invocationsDone() && afterConnCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Conn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ConnMock.expectedInvocations), m.ConnMock.expectedInvocationsOrigin, afterConnCounter)
	}
}

type mTxMockCopyFrom struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockCopyFromExpectation
	expectations       []*TxMockCopyFromExpectation

	callArgs []*TxMockCopyFromParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockCopyFromExpectation specifies expectation struct of the Tx.CopyFrom
type TxMockCopyFromExpectation struct {
	mock               *TxMock
	params             *TxMockCopyFromParams
	paramPtrs          *TxMockCopyFromParamPtrs
	expectationOrigins TxMockCopyFromExpectationOrigins
	results            *TxMockCopyFromResults
	returnOrigin       string
	Counter            uint64
}

// TxMockCopyFromParams contains parameters of the Tx.CopyFrom
type TxMockCopyFromParams struct {
	ctx         context.Context
	tableName   mm_pgx.Identifier
	columnNames []string
	rowSrc      mm_pgx.CopyFromSource
}

// TxMockCopyFromParamPtrs contains pointers to parameters of the Tx.CopyFrom
type TxMockCopyFromParamPtrs struct {
	ctx         *context.Context
	tableName   *mm_pgx.Identifier
	columnNames *[]string
	rowSrc      *mm_pgx.CopyFromSource
}

// TxMockCopyFromResults contains results of the Tx.CopyFrom
type TxMockCopyFromResults struct {
	i1  int64
	err error
}

// TxMockCopyFromOrigins contains origins of expectations of the Tx.CopyFrom
type TxMockCopyFromExpectationOrigins struct {
	origin            string
	originCtx         string
	originTableName   string
	originColumnNames string
	originRowSrc      string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCopyFrom *mTxMockCopyFrom) Optional() *mTxMockCopyFrom {
	mmCopyFrom.optional = true
	return mmCopyFrom
}

// Expect sets up expected params for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Expect(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.paramPtrs != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by ExpectParams functions")
	}

	mmCopyFrom.defaultExpectation.params = &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	mmCopyFrom.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// ExpectCtxParam1 sets up expected param ctx for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectCtxParam1(ctx context.Context) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.ctx = &ctx
	mmCopyFrom.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectTableNameParam2 sets up expected param tableName for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectTableNameParam2(tableName mm_pgx.Identifier) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.tableName = &tableName
	mmCopyFrom.defaultExpectation.expectationOrigins.originTableName = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectColumnNamesParam3 sets up expected param columnNames for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectColumnNamesParam3(columnNames []string) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.columnNames = &columnNames
	mmCopyFrom.defaultExpectation.expectationOrigins.originColumnNames = minimock.CallerInfo(1)

	return mmCopyFrom
}

// ExpectRowSrcParam4 sets up expected param rowSrc for Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) ExpectRowSrcParam4(rowSrc mm_pgx.CopyFromSource) *mTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{}
	}

	if mmCopyFrom.defaultExpectation.params != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Expect")
	}

	if mmCopyFrom.defaultExpectation.paramPtrs == nil {
		mmCopyFrom.defaultExpectation.paramPtrs = &TxMockCopyFromParamPtrs{}
	}
	mmCopyFrom.defaultExpectation.paramPtrs.rowSrc = &rowSrc
	mmCopyFrom.defaultExpectation.expectationOrigins.originRowSrc = minimock.CallerInfo(1)

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Inspect(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource)) *mTxMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for TxMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by Tx.CopyFrom
func (mmCopyFrom *mTxMockCopyFrom) Return(i1 int64, err error) *TxMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &TxMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &TxMockCopyFromResults{i1, err}
	mmCopyFrom.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCopyFrom.mock
}

// Set uses given function f to mock the Tx.CopyFrom method
func (mmCopyFrom *mTxMockCopyFrom) Set(f func(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error)) *TxMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the Tx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the Tx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	mmCopyFrom.mock.funcCopyFromOrigin = minimock.CallerInfo(1)
	return mmCopyFrom.mock
}

// When sets expectation for the Tx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mTxMockCopyFrom) When(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) *TxMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("TxMock.CopyFrom mock is already set by Set")
	}

	expectation := &TxMockCopyFromExpectation{
		mock:               mmCopyFrom.mock,
		params:             &TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
		expectationOrigins: TxMockCopyFromExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up Tx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *TxMockCopyFromExpectation) Then(i1 int64, err error) *TxMock {
	e.results = &TxMockCopyFromResults{i1, err}
	return e.mock
}

// Times sets number of times Tx.CopyFrom should be invoked
func (mmCopyFrom *mTxMockCopyFrom) Times(n uint64) *mTxMockCopyFrom {
	if n == 0 {
		mmCopyFrom.mock.t.Fatalf("Times of TxMock.CopyFrom mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCopyFrom.expectedInvocations, n)
	mmCopyFrom.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCopyFrom
}

func (mmCopyFrom *mTxMockCopyFrom) invocationsDone() bool {
	if len(mmCopyFrom.expectations) == 0 && mmCopyFrom.defaultExpectation == nil && mmCopyFrom.mock.funcCopyFrom == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCopyFrom.mock.afterCopyFromCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCopyFrom.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CopyFrom implements mm_pgx.Tx
func (mmCopyFrom *TxMock) CopyFrom(ctx context.Context, tableName mm_pgx.Identifier, columnNames []string, rowSrc mm_pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	mmCopyFrom.t.Helper()

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, &mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_want_ptrs := mmCopyFrom.CopyFromMock.defaultExpectation.paramPtrs

		mm_got := TxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tableName != nil && !minimock.Equal(*mm_want_ptrs.tableName, mm_got.tableName) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter tableName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originTableName, *mm_want_ptrs.tableName, mm_got.tableName, minimock.Diff(*mm_want_ptrs.tableName, mm_got.tableName))
			}

			if mm_want_ptrs.columnNames != nil && !minimock.Equal(*mm_want_ptrs.columnNames, mm_got.columnNames) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter columnNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originColumnNames, *mm_want_ptrs.columnNames, mm_got.columnNames, minimock.Diff(*mm_want_ptrs.columnNames, mm_got.columnNames))
			}

			if mm_want_ptrs.rowSrc != nil && !minimock.Equal(*mm_want_ptrs.rowSrc, mm_got.rowSrc) {
				mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameter rowSrc, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.originRowSrc, *mm_want_ptrs.rowSrc, mm_got.rowSrc, minimock.Diff(*mm_want_ptrs.rowSrc, mm_got.rowSrc))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("TxMock.CopyFrom got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCopyFrom.CopyFromMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the TxMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to TxMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of TxMock.CopyFrom invocations
func (mmCopyFrom *TxMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to TxMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mTxMockCopyFrom) Calls() []*TxMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*TxMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockCopyFromDone() bool {
	if m.CopyFromMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CopyFromMock.invocationsDone()
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *TxMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.CopyFrom at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCopyFromCounter := mm_atomic.LoadUint64(&m.afterCopyFromCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && afterCopyFromCounter < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.CopyFrom at\n%s", m.CopyFromMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.CopyFrom at\n%s with params: %#v", m.CopyFromMock.defaultExpectation.expectationOrigins.origin, *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && afterCopyFromCounter < 1 {
		m.t.Errorf("Expected call to TxMock.CopyFrom at\n%s", m.funcCopyFromOrigin)
	}

	if !m.CopyFromMock.invocationsDone() && afterCopyFromCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.CopyFrom at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CopyFromMock.expectedInvocations), m.CopyFromMock.expectedInvocationsOrigin, afterCopyFromCounter)
	}
}

type mTxMockExec struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockExecExpectation
	expectations       []*TxMockExecExpectation

	callArgs []*TxMockExecParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockExecExpectation specifies expectation struct of the Tx.Exec
type TxMockExecExpectation struct {
	mock               *TxMock
	params             *TxMockExecParams
	paramPtrs          *TxMockExecParamPtrs
	expectationOrigins TxMockExecExpectationOrigins
	results            *TxMockExecResults
	returnOrigin       string
	Counter            uint64
}

// TxMockExecParams contains parameters of the Tx.Exec
type TxMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []any
}

// TxMockExecParamPtrs contains pointers to parameters of the Tx.Exec
type TxMockExecParamPtrs struct {
	ctx       *context.Context
	sql       *string
	arguments *[]any
}

// TxMockExecResults contains results of the Tx.Exec
type TxMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// TxMockExecOrigins contains origins of expectations of the Tx.Exec
type TxMockExecExpectationOrigins struct {
	origin          string
	originCtx       string
	originSql       string
	originArguments string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExec *mTxMockExec) Optional() *mTxMockExec {
	mmExec.optional = true
	return mmExec
}

// Expect sets up expected params for Tx.Exec
func (mmExec *mTxMockExec) Expect(ctx context.Context, sql string, arguments ...any) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.paramPtrs != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by ExpectParams functions")
	}

	mmExec.defaultExpectation.params = &TxMockExecParams{ctx, sql, arguments}
	mmExec.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Exec
func (mmExec *mTxMockExec) ExpectCtxParam1(ctx context.Context) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.ctx = &ctx
	mmExec.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmExec
}

// ExpectSqlParam2 sets up expected param sql for Tx.Exec
func (mmExec *mTxMockExec) ExpectSqlParam2(sql string) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.sql = &sql
	mmExec.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmExec
}

// ExpectArgumentsParam3 sets up expected param arguments for Tx.Exec
func (mmExec *mTxMockExec) ExpectArgumentsParam3(arguments ...any) *mTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{}
	}

	if mmExec.defaultExpectation.params != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Expect")
	}

	if mmExec.defaultExpectation.paramPtrs == nil {
		mmExec.defaultExpectation.paramPtrs = &TxMockExecParamPtrs{}
	}
	mmExec.defaultExpectation.paramPtrs.arguments = &arguments
	mmExec.defaultExpectation.expectationOrigins.originArguments = minimock.CallerInfo(1)

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the Tx.Exec
func (mmExec *mTxMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...any)) *mTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for TxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by Tx.Exec
func (mmExec *mTxMockExec) Return(commandTag pgconn.CommandTag, err error) *TxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &TxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &TxMockExecResults{commandTag, err}
	mmExec.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// Set uses given function f to mock the Tx.Exec method
func (mmExec *mTxMockExec) Set(f func(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)) *TxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the Tx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the Tx.Exec method")
	}

	mmExec.mock.funcExec = f
	mmExec.mock.funcExecOrigin = minimock.CallerInfo(1)
	return mmExec.mock
}

// When sets expectation for the Tx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mTxMockExec) When(ctx context.Context, sql string, arguments ...any) *TxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("TxMock.Exec mock is already set by Set")
	}

	expectation := &TxMockExecExpectation{
		mock:               mmExec.mock,
		params:             &TxMockExecParams{ctx, sql, arguments},
		expectationOrigins: TxMockExecExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up Tx.Exec return parameters for the expectation previously defined by the When method
func (e *TxMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *TxMock {
	e.results = &TxMockExecResults{commandTag, err}
	return e.mock
}

// Times sets number of times Tx.Exec should be invoked
func (mmExec *mTxMockExec) Times(n uint64) *mTxMockExec {
	if n == 0 {
		mmExec.mock.t.Fatalf("Times of TxMock.Exec mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExec.expectedInvocations, n)
	mmExec.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExec
}

func (mmExec *mTxMockExec) invocationsDone() bool {
	if len(mmExec.expectations) == 0 && mmExec.defaultExpectation == nil && mmExec.mock.funcExec == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExec.mock.afterExecCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExec.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Exec implements mm_pgx.Tx
func (mmExec *TxMock) Exec(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	mmExec.t.Helper()

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := TxMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_want_ptrs := mmExec.ExecMock.defaultExpectation.paramPtrs

		mm_got := TxMockExecParams{ctx, sql, arguments}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.arguments != nil && !minimock.Equal(*mm_want_ptrs.arguments, mm_got.arguments) {
				mmExec.t.Errorf("TxMock.Exec got unexpected parameter arguments, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExec.ExecMock.defaultExpectation.expectationOrigins.originArguments, *mm_want_ptrs.arguments, mm_got.arguments, minimock.Diff(*mm_want_ptrs.arguments, mm_got.arguments))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("TxMock.Exec got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExec.ExecMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the TxMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to TxMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished TxMock.Exec invocations
func (mmExec *TxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of TxMock.Exec invocations
func (mmExec *TxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mTxMockExec) Calls() []*TxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*TxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockExecDone() bool {
	if m.ExecMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExecMock.invocationsDone()
}

// MinimockExecInspect logs each unmet expectation
func (m *TxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Exec at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExecCounter := mm_atomic.LoadUint64(&m.afterExecCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && afterExecCounter < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.Exec at\n%s", m.ExecMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.Exec at\n%s with params: %#v", m.ExecMock.defaultExpectation.expectationOrigins.origin, *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && afterExecCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Exec at\n%s", m.funcExecOrigin)
	}

	if !m.ExecMock.invocationsDone() && afterExecCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Exec at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExecMock.expectedInvocations), m.ExecMock.expectedInvocationsOrigin, afterExecCounter)
	}
}

type mTxMockLargeObjects struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockLargeObjectsExpectation
	expectations       []*TxMockLargeObjectsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockLargeObjectsExpectation specifies expectation struct of the Tx.LargeObjects
type TxMockLargeObjectsExpectation struct {
	mock *TxMock

	results      *TxMockLargeObjectsResults
	returnOrigin string
	Counter      uint64
}

// TxMockLargeObjectsResults contains results of the Tx.LargeObjects
type TxMockLargeObjectsResults struct {
	l1 mm_pgx.LargeObjects
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLargeObjects *mTxMockLargeObjects) Optional() *mTxMockLargeObjects {
	mmLargeObjects.optional = true
	return mmLargeObjects
}

// Expect sets up expected params for Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Expect() *mTxMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Inspect(f func()) *mTxMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for TxMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by Tx.LargeObjects
func (mmLargeObjects *mTxMockLargeObjects) Return(l1 mm_pgx.LargeObjects) *TxMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("TxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &TxMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &TxMockLargeObjectsResults{l1}
	mmLargeObjects.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLargeObjects.mock
}

// Set uses given function f to mock the Tx.LargeObjects method
func (mmLargeObjects *mTxMockLargeObjects) Set(f func() (l1 mm_pgx.LargeObjects)) *TxMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the Tx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the Tx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	mmLargeObjects.mock.funcLargeObjectsOrigin = minimock.CallerInfo(1)
	return mmLargeObjects.mock
}

// Times sets number of times Tx.LargeObjects should be invoked
func (mmLargeObjects *mTxMockLargeObjects) Times(n uint64) *mTxMockLargeObjects {
	if n == 0 {
		mmLargeObjects.mock.t.Fatalf("Times of TxMock.LargeObjects mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLargeObjects.expectedInvocations, n)
	mmLargeObjects.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLargeObjects
}

func (mmLargeObjects *mTxMockLargeObjects) invocationsDone() bool {
	if len(mmLargeObjects.expectations) == 0 && mmLargeObjects.defaultExpectation == nil && mmLargeObjects.mock.funcLargeObjects == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLargeObjects.mock.afterLargeObjectsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLargeObjects.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// LargeObjects implements mm_pgx.Tx
func (mmLargeObjects *TxMock) LargeObjects() (l1 mm_pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	mmLargeObjects.t.Helper()

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the TxMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to TxMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of TxMock.LargeObjects invocations
func (mmLargeObjects *TxMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockLargeObjectsDone() bool {
	if m.LargeObjectsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LargeObjectsMock.invocationsDone()
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *TxMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TxMock.LargeObjects")
		}
	}

	afterLargeObjectsCounter := mm_atomic.LoadUint64(&m.afterLargeObjectsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && afterLargeObjectsCounter < 1 {
		m.t.Errorf("Expected call to TxMock.LargeObjects at\n%s", m.LargeObjectsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && afterLargeObjectsCounter < 1 {
		m.t.Errorf("Expected call to TxMock.LargeObjects at\n%s", m.funcLargeObjectsOrigin)
	}

	if !m.LargeObjectsMock.invocationsDone() && afterLargeObjectsCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.LargeObjects at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LargeObjectsMock.expectedInvocations), m.LargeObjectsMock.expectedInvocationsOrigin, afterLargeObjectsCounter)
	}
}

type mTxMockPrepare struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockPrepareExpectation
	expectations       []*TxMockPrepareExpectation

	callArgs []*TxMockPrepareParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockPrepareExpectation specifies expectation struct of the Tx.Prepare
type TxMockPrepareExpectation struct {
	mock               *TxMock
	params             *TxMockPrepareParams
	paramPtrs          *TxMockPrepareParamPtrs
	expectationOrigins TxMockPrepareExpectationOrigins
	results            *TxMockPrepareResults
	returnOrigin       string
	Counter            uint64
}

// TxMockPrepareParams contains parameters of the Tx.Prepare
type TxMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// TxMockPrepareParamPtrs contains pointers to parameters of the Tx.Prepare
type TxMockPrepareParamPtrs struct {
	ctx  *context.Context
	name *string
	sql  *string
}

// TxMockPrepareResults contains results of the Tx.Prepare
type TxMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// TxMockPrepareOrigins contains origins of expectations of the Tx.Prepare
type TxMockPrepareExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
	originSql  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrepare *mTxMockPrepare) Optional() *mTxMockPrepare {
	mmPrepare.optional = true
	return mmPrepare
}

// Expect sets up expected params for Tx.Prepare
func (mmPrepare *mTxMockPrepare) Expect(ctx context.Context, name string, sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.paramPtrs != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by ExpectParams functions")
	}

	mmPrepare.defaultExpectation.params = &TxMockPrepareParams{ctx, name, sql}
	mmPrepare.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectCtxParam1(ctx context.Context) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.ctx = &ctx
	mmPrepare.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPrepare
}

// ExpectNameParam2 sets up expected param name for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectNameParam2(name string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.name = &name
	mmPrepare.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmPrepare
}

// ExpectSqlParam3 sets up expected param sql for Tx.Prepare
func (mmPrepare *mTxMockPrepare) ExpectSqlParam3(sql string) *mTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{}
	}

	if mmPrepare.defaultExpectation.params != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Expect")
	}

	if mmPrepare.defaultExpectation.paramPtrs == nil {
		mmPrepare.defaultExpectation.paramPtrs = &TxMockPrepareParamPtrs{}
	}
	mmPrepare.defaultExpectation.paramPtrs.sql = &sql
	mmPrepare.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the Tx.Prepare
func (mmPrepare *mTxMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for TxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by Tx.Prepare
func (mmPrepare *mTxMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *TxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &TxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &TxMockPrepareResults{sp1, err}
	mmPrepare.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrepare.mock
}

// Set uses given function f to mock the Tx.Prepare method
func (mmPrepare *mTxMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *TxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the Tx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the Tx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	mmPrepare.mock.funcPrepareOrigin = minimock.CallerInfo(1)
	return mmPrepare.mock
}

// When sets expectation for the Tx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mTxMockPrepare) When(ctx context.Context, name string, sql string) *TxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("TxMock.Prepare mock is already set by Set")
	}

	expectation := &TxMockPrepareExpectation{
		mock:               mmPrepare.mock,
		params:             &TxMockPrepareParams{ctx, name, sql},
		expectationOrigins: TxMockPrepareExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up Tx.Prepare return parameters for the expectation previously defined by the When method
func (e *TxMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *TxMock {
	e.results = &TxMockPrepareResults{sp1, err}
	return e.mock
}

// Times sets number of times Tx.Prepare should be invoked
func (mmPrepare *mTxMockPrepare) Times(n uint64) *mTxMockPrepare {
	if n == 0 {
		mmPrepare.mock.t.Fatalf("Times of TxMock.Prepare mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrepare.expectedInvocations, n)
	mmPrepare.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrepare
}

func (mmPrepare *mTxMockPrepare) invocationsDone() bool {
	if len(mmPrepare.expectations) == 0 && mmPrepare.defaultExpectation == nil && mmPrepare.mock.funcPrepare == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrepare.mock.afterPrepareCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrepare.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Prepare implements mm_pgx.Tx
func (mmPrepare *TxMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	mmPrepare.t.Helper()

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := TxMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, &mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_want_ptrs := mmPrepare.PrepareMock.defaultExpectation.paramPtrs

		mm_got := TxMockPrepareParams{ctx, name, sql}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("TxMock.Prepare got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrepare.PrepareMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the TxMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to TxMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of TxMock.Prepare invocations
func (mmPrepare *TxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mTxMockPrepare) Calls() []*TxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*TxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockPrepareDone() bool {
	if m.PrepareMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrepareMock.invocationsDone()
}

// MinimockPrepareInspect logs each unmet expectation
func (m *TxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Prepare at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrepareCounter := mm_atomic.LoadUint64(&m.afterPrepareCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && afterPrepareCounter < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.Prepare at\n%s", m.PrepareMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.Prepare at\n%s with params: %#v", m.PrepareMock.defaultExpectation.expectationOrigins.origin, *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && afterPrepareCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Prepare at\n%s", m.funcPrepareOrigin)
	}

	if !m.PrepareMock.invocationsDone() && afterPrepareCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Prepare at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrepareMock.expectedInvocations), m.PrepareMock.expectedInvocationsOrigin, afterPrepareCounter)
	}
}

type mTxMockQuery struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryExpectation
	expectations       []*TxMockQueryExpectation

	callArgs []*TxMockQueryParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockQueryExpectation specifies expectation struct of the Tx.Query
type TxMockQueryExpectation struct {
	mock               *TxMock
	params             *TxMockQueryParams
	paramPtrs          *TxMockQueryParamPtrs
	expectationOrigins TxMockQueryExpectationOrigins
	results            *TxMockQueryResults
	returnOrigin       string
	Counter            uint64
}

// TxMockQueryParams contains parameters of the Tx.Query
type TxMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []any
}

// TxMockQueryParamPtrs contains pointers to parameters of the Tx.Query
type TxMockQueryParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]any
}

// TxMockQueryResults contains results of the Tx.Query
type TxMockQueryResults struct {
	r1  mm_pgx.Rows
	err error
}

// TxMockQueryOrigins contains origins of expectations of the Tx.Query
type TxMockQueryExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQuery *mTxMockQuery) Optional() *mTxMockQuery {
	mmQuery.optional = true
	return mmQuery
}

// Expect sets up expected params for Tx.Query
func (mmQuery *mTxMockQuery) Expect(ctx context.Context, sql string, args ...any) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.paramPtrs != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by ExpectParams functions")
	}

	mmQuery.defaultExpectation.params = &TxMockQueryParams{ctx, sql, args}
	mmQuery.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Query
func (mmQuery *mTxMockQuery) ExpectCtxParam1(ctx context.Context) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.ctx = &ctx
	mmQuery.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectSqlParam2 sets up expected param sql for Tx.Query
func (mmQuery *mTxMockQuery) ExpectSqlParam2(sql string) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.sql = &sql
	mmQuery.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQuery
}

// ExpectArgsParam3 sets up expected param args for Tx.Query
func (mmQuery *mTxMockQuery) ExpectArgsParam3(args ...any) *mTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{}
	}

	if mmQuery.defaultExpectation.params != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Expect")
	}

	if mmQuery.defaultExpectation.paramPtrs == nil {
		mmQuery.defaultExpectation.paramPtrs = &TxMockQueryParamPtrs{}
	}
	mmQuery.defaultExpectation.paramPtrs.args = &args
	mmQuery.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the Tx.Query
func (mmQuery *mTxMockQuery) Inspect(f func(ctx context.Context, sql string, args ...any)) *mTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for TxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by Tx.Query
func (mmQuery *mTxMockQuery) Return(r1 mm_pgx.Rows, err error) *TxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &TxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &TxMockQueryResults{r1, err}
	mmQuery.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// Set uses given function f to mock the Tx.Query method
func (mmQuery *mTxMockQuery) Set(f func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Rows, err error)) *TxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the Tx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the Tx.Query method")
	}

	mmQuery.mock.funcQuery = f
	mmQuery.mock.funcQueryOrigin = minimock.CallerInfo(1)
	return mmQuery.mock
}

// When sets expectation for the Tx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mTxMockQuery) When(ctx context.Context, sql string, args ...any) *TxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("TxMock.Query mock is already set by Set")
	}

	expectation := &TxMockQueryExpectation{
		mock:               mmQuery.mock,
		params:             &TxMockQueryParams{ctx, sql, args},
		expectationOrigins: TxMockQueryExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up Tx.Query return parameters for the expectation previously defined by the When method
func (e *TxMockQueryExpectation) Then(r1 mm_pgx.Rows, err error) *TxMock {
	e.results = &TxMockQueryResults{r1, err}
	return e.mock
}

// Times sets number of times Tx.Query should be invoked
func (mmQuery *mTxMockQuery) Times(n uint64) *mTxMockQuery {
	if n == 0 {
		mmQuery.mock.t.Fatalf("Times of TxMock.Query mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQuery.expectedInvocations, n)
	mmQuery.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQuery
}

func (mmQuery *mTxMockQuery) invocationsDone() bool {
	if len(mmQuery.expectations) == 0 && mmQuery.defaultExpectation == nil && mmQuery.mock.funcQuery == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQuery.mock.afterQueryCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQuery.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Query implements mm_pgx.Tx
func (mmQuery *TxMock) Query(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	mmQuery.t.Helper()

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := TxMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_want_ptrs := mmQuery.QueryMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQuery.t.Errorf("TxMock.Query got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQuery.QueryMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("TxMock.Query got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQuery.QueryMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the TxMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to TxMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished TxMock.Query invocations
func (mmQuery *TxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of TxMock.Query invocations
func (mmQuery *TxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mTxMockQuery) Calls() []*TxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*TxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryDone() bool {
	if m.QueryMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryMock.invocationsDone()
}

// MinimockQueryInspect logs each unmet expectation
func (m *TxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Query at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryCounter := mm_atomic.LoadUint64(&m.afterQueryCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && afterQueryCounter < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.Query at\n%s", m.QueryMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.Query at\n%s with params: %#v", m.QueryMock.defaultExpectation.expectationOrigins.origin, *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && afterQueryCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Query at\n%s", m.funcQueryOrigin)
	}

	if !m.QueryMock.invocationsDone() && afterQueryCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Query at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryMock.expectedInvocations), m.QueryMock.expectedInvocationsOrigin, afterQueryCounter)
	}
}

type mTxMockQueryRow struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockQueryRowExpectation
	expectations       []*TxMockQueryRowExpectation

	callArgs []*TxMockQueryRowParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockQueryRowExpectation specifies expectation struct of the Tx.QueryRow
type TxMockQueryRowExpectation struct {
	mock               *TxMock
	params             *TxMockQueryRowParams
	paramPtrs          *TxMockQueryRowParamPtrs
	expectationOrigins TxMockQueryRowExpectationOrigins
	results            *TxMockQueryRowResults
	returnOrigin       string
	Counter            uint64
}

// TxMockQueryRowParams contains parameters of the Tx.QueryRow
type TxMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []any
}

// TxMockQueryRowParamPtrs contains pointers to parameters of the Tx.QueryRow
type TxMockQueryRowParamPtrs struct {
	ctx  *context.Context
	sql  *string
	args *[]any
}

// TxMockQueryRowResults contains results of the Tx.QueryRow
type TxMockQueryRowResults struct {
	r1 mm_pgx.Row
}

// TxMockQueryRowOrigins contains origins of expectations of the Tx.QueryRow
type TxMockQueryRowExpectationOrigins struct {
	origin     string
	originCtx  string
	originSql  string
	originArgs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmQueryRow *mTxMockQueryRow) Optional() *mTxMockQueryRow {
	mmQueryRow.optional = true
	return mmQueryRow
}

// Expect sets up expected params for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Expect(ctx context.Context, sql string, args ...any) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.paramPtrs != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by ExpectParams functions")
	}

	mmQueryRow.defaultExpectation.params = &TxMockQueryRowParams{ctx, sql, args}
	mmQueryRow.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// ExpectCtxParam1 sets up expected param ctx for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectCtxParam1(ctx context.Context) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.ctx = &ctx
	mmQueryRow.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmQueryRow
}

// ExpectSqlParam2 sets up expected param sql for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectSqlParam2(sql string) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.sql = &sql
	mmQueryRow.defaultExpectation.expectationOrigins.originSql = minimock.CallerInfo(1)

	return mmQueryRow
}

// ExpectArgsParam3 sets up expected param args for Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) ExpectArgsParam3(args ...any) *mTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{}
	}

	if mmQueryRow.defaultExpectation.params != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Expect")
	}

	if mmQueryRow.defaultExpectation.paramPtrs == nil {
		mmQueryRow.defaultExpectation.paramPtrs = &TxMockQueryRowParamPtrs{}
	}
	mmQueryRow.defaultExpectation.paramPtrs.args = &args
	mmQueryRow.defaultExpectation.expectationOrigins.originArgs = minimock.CallerInfo(1)

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...any)) *mTxMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for TxMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by Tx.QueryRow
func (mmQueryRow *mTxMockQueryRow) Return(r1 mm_pgx.Row) *TxMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &TxMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &TxMockQueryRowResults{r1}
	mmQueryRow.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmQueryRow.mock
}

// Set uses given function f to mock the Tx.QueryRow method
func (mmQueryRow *mTxMockQueryRow) Set(f func(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Row)) *TxMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the Tx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the Tx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	mmQueryRow.mock.funcQueryRowOrigin = minimock.CallerInfo(1)
	return mmQueryRow.mock
}

// When sets expectation for the Tx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mTxMockQueryRow) When(ctx context.Context, sql string, args ...any) *TxMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("TxMock.QueryRow mock is already set by Set")
	}

	expectation := &TxMockQueryRowExpectation{
		mock:               mmQueryRow.mock,
		params:             &TxMockQueryRowParams{ctx, sql, args},
		expectationOrigins: TxMockQueryRowExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up Tx.QueryRow return parameters for the expectation previously defined by the When method
func (e *TxMockQueryRowExpectation) Then(r1 mm_pgx.Row) *TxMock {
	e.results = &TxMockQueryRowResults{r1}
	return e.mock
}

// Times sets number of times Tx.QueryRow should be invoked
func (mmQueryRow *mTxMockQueryRow) Times(n uint64) *mTxMockQueryRow {
	if n == 0 {
		mmQueryRow.mock.t.Fatalf("Times of TxMock.QueryRow mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmQueryRow.expectedInvocations, n)
	mmQueryRow.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmQueryRow
}

func (mmQueryRow *mTxMockQueryRow) invocationsDone() bool {
	if len(mmQueryRow.expectations) == 0 && mmQueryRow.defaultExpectation == nil && mmQueryRow.mock.funcQueryRow == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmQueryRow.mock.afterQueryRowCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmQueryRow.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// QueryRow implements mm_pgx.Tx
func (mmQueryRow *TxMock) QueryRow(ctx context.Context, sql string, args ...any) (r1 mm_pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	mmQueryRow.t.Helper()

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := TxMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_want_ptrs := mmQueryRow.QueryRowMock.defaultExpectation.paramPtrs

		mm_got := TxMockQueryRowParams{ctx, sql, args}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sql != nil && !minimock.Equal(*mm_want_ptrs.sql, mm_got.sql) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter sql, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originSql, *mm_want_ptrs.sql, mm_got.sql, minimock.Diff(*mm_want_ptrs.sql, mm_got.sql))
			}

			if mm_want_ptrs.args != nil && !minimock.Equal(*mm_want_ptrs.args, mm_got.args) {
				mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameter args, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.originArgs, *mm_want_ptrs.args, mm_got.args, minimock.Diff(*mm_want_ptrs.args, mm_got.args))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("TxMock.QueryRow got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmQueryRow.QueryRowMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the TxMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to TxMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of TxMock.QueryRow invocations
func (mmQueryRow *TxMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to TxMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mTxMockQueryRow) Calls() []*TxMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*TxMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockQueryRowDone() bool {
	if m.QueryRowMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.QueryRowMock.invocationsDone()
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *TxMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.QueryRow at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterQueryRowCounter := mm_atomic.LoadUint64(&m.afterQueryRowCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && afterQueryRowCounter < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.QueryRow at\n%s", m.QueryRowMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.QueryRow at\n%s with params: %#v", m.QueryRowMock.defaultExpectation.expectationOrigins.origin, *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && afterQueryRowCounter < 1 {
		m.t.Errorf("Expected call to TxMock.QueryRow at\n%s", m.funcQueryRowOrigin)
	}

	if !m.QueryRowMock.invocationsDone() && afterQueryRowCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.QueryRow at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.QueryRowMock.expectedInvocations), m.QueryRowMock.expectedInvocationsOrigin, afterQueryRowCounter)
	}
}

type mTxMockRollback struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockRollbackExpectation
	expectations       []*TxMockRollbackExpectation

	callArgs []*TxMockRollbackParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockRollbackExpectation specifies expectation struct of the Tx.Rollback
type TxMockRollbackExpectation struct {
	mock               *TxMock
	params             *TxMockRollbackParams
	paramPtrs          *TxMockRollbackParamPtrs
	expectationOrigins TxMockRollbackExpectationOrigins
	results            *TxMockRollbackResults
	returnOrigin       string
	Counter            uint64
}

// TxMockRollbackParams contains parameters of the Tx.Rollback
type TxMockRollbackParams struct {
	ctx context.Context
}

// TxMockRollbackParamPtrs contains pointers to parameters of the Tx.Rollback
type TxMockRollbackParamPtrs struct {
	ctx *context.Context
}

// TxMockRollbackResults contains results of the Tx.Rollback
type TxMockRollbackResults struct {
	err error
}

// TxMockRollbackOrigins contains origins of expectations of the Tx.Rollback
type TxMockRollbackExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollback *mTxMockRollback) Optional() *mTxMockRollback {
	mmRollback.optional = true
	return mmRollback
}

// Expect sets up expected params for Tx.Rollback
func (mmRollback *mTxMockRollback) Expect(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.paramPtrs != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by ExpectParams functions")
	}

	mmRollback.defaultExpectation.params = &TxMockRollbackParams{ctx}
	mmRollback.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// ExpectCtxParam1 sets up expected param ctx for Tx.Rollback
func (mmRollback *mTxMockRollback) ExpectCtxParam1(ctx context.Context) *mTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{}
	}

	if mmRollback.defaultExpectation.params != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Expect")
	}

	if mmRollback.defaultExpectation.paramPtrs == nil {
		mmRollback.defaultExpectation.paramPtrs = &TxMockRollbackParamPtrs{}
	}
	mmRollback.defaultExpectation.paramPtrs.ctx = &ctx
	mmRollback.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the Tx.Rollback
func (mmRollback *mTxMockRollback) Inspect(f func(ctx context.Context)) *mTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for TxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by Tx.Rollback
func (mmRollback *mTxMockRollback) Return(err error) *TxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &TxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &TxMockRollbackResults{err}
	mmRollback.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// Set uses given function f to mock the Tx.Rollback method
func (mmRollback *mTxMockRollback) Set(f func(ctx context.Context) (err error)) *TxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the Tx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the Tx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	mmRollback.mock.funcRollbackOrigin = minimock.CallerInfo(1)
	return mmRollback.mock
}

// When sets expectation for the Tx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mTxMockRollback) When(ctx context.Context) *TxMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("TxMock.Rollback mock is already set by Set")
	}

	expectation := &TxMockRollbackExpectation{
		mock:               mmRollback.mock,
		params:             &TxMockRollbackParams{ctx},
		expectationOrigins: TxMockRollbackExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up Tx.Rollback return parameters for the expectation previously defined by the When method
func (e *TxMockRollbackExpectation) Then(err error) *TxMock {
	e.results = &TxMockRollbackResults{err}
	return e.mock
}

// Times sets number of times Tx.Rollback should be invoked
func (mmRollback *mTxMockRollback) Times(n uint64) *mTxMockRollback {
	if n == 0 {
		mmRollback.mock.t.Fatalf("Times of TxMock.Rollback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollback.expectedInvocations, n)
	mmRollback.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRollback
}

func (mmRollback *mTxMockRollback) invocationsDone() bool {
	if len(mmRollback.expectations) == 0 && mmRollback.defaultExpectation == nil && mmRollback.mock.funcRollback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollback.mock.afterRollbackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Rollback implements mm_pgx.Tx
func (mmRollback *TxMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	mmRollback.t.Helper()

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := TxMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, &mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_want_ptrs := mmRollback.RollbackMock.defaultExpectation.paramPtrs

		mm_got := TxMockRollbackParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollback.t.Errorf("TxMock.Rollback got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollback.RollbackMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("TxMock.Rollback got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRollback.RollbackMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the TxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to TxMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of TxMock.Rollback invocations
func (mmRollback *TxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to TxMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mTxMockRollback) Calls() []*TxMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*TxMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockRollbackDone() bool {
	if m.RollbackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackMock.invocationsDone()
}

// MinimockRollbackInspect logs each unmet expectation
func (m *TxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.Rollback at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRollbackCounter := mm_atomic.LoadUint64(&m.afterRollbackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && afterRollbackCounter < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.Rollback at\n%s", m.RollbackMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.Rollback at\n%s with params: %#v", m.RollbackMock.defaultExpectation.expectationOrigins.origin, *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && afterRollbackCounter < 1 {
		m.t.Errorf("Expected call to TxMock.Rollback at\n%s", m.funcRollbackOrigin)
	}

	if !m.RollbackMock.invocationsDone() && afterRollbackCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.Rollback at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackMock.expectedInvocations), m.RollbackMock.expectedInvocationsOrigin, afterRollbackCounter)
	}
}

type mTxMockSendBatch struct {
	optional           bool
	mock               *TxMock
	defaultExpectation *TxMockSendBatchExpectation
	expectations       []*TxMockSendBatchExpectation

	callArgs []*TxMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TxMockSendBatchExpectation specifies expectation struct of the Tx.SendBatch
type TxMockSendBatchExpectation struct {
	mock               *TxMock
	params             *TxMockSendBatchParams
	paramPtrs          *TxMockSendBatchParamPtrs
	expectationOrigins TxMockSendBatchExpectationOrigins
	results            *TxMockSendBatchResults
	returnOrigin       string
	Counter            uint64
}

// TxMockSendBatchParams contains parameters of the Tx.SendBatch
type TxMockSendBatchParams struct {
	ctx context.Context
	b   *mm_pgx.Batch
}

// TxMockSendBatchParamPtrs contains pointers to parameters of the Tx.SendBatch
type TxMockSendBatchParamPtrs struct {
	ctx *context.Context
	b   **mm_pgx.Batch
}

// TxMockSendBatchResults contains results of the Tx.SendBatch
type TxMockSendBatchResults struct {
	b1 mm_pgx.BatchResults
}

// TxMockSendBatchOrigins contains origins of expectations of the Tx.SendBatch
type TxMockSendBatchExpectationOrigins struct {
	origin    string
	originCtx string
	originB   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mTxMockSendBatch) Optional() *mTxMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Expect(ctx context.Context, b *mm_pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &TxMockSendBatchParams{ctx, b}
	mmSendBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectCtxParam1 sets up expected param ctx for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) ExpectCtxParam1(ctx context.Context) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendBatch.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendBatch
}

// ExpectBParam2 sets up expected param b for Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) ExpectBParam2(b *mm_pgx.Batch) *mTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &TxMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.b = &b
	mmSendBatch.defaultExpectation.expectationOrigins.originB = minimock.CallerInfo(1)

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Inspect(f func(ctx context.Context, b *mm_pgx.Batch)) *mTxMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for TxMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Tx.SendBatch
func (mmSendBatch *mTxMockSendBatch) Return(b1 mm_pgx.BatchResults) *TxMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &TxMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &TxMockSendBatchResults{b1}
	mmSendBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// Set uses given function f to mock the Tx.SendBatch method
func (mmSendBatch *mTxMockSendBatch) Set(f func(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults)) *TxMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Tx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Tx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	mmSendBatch.mock.funcSendBatchOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// When sets expectation for the Tx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mTxMockSendBatch) When(ctx context.Context, b *mm_pgx.Batch) *TxMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("TxMock.SendBatch mock is already set by Set")
	}

	expectation := &TxMockSendBatchExpectation{
		mock:               mmSendBatch.mock,
		params:             &TxMockSendBatchParams{ctx, b},
		expectationOrigins: TxMockSendBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Tx.SendBatch return parameters for the expectation previously defined by the When method
func (e *TxMockSendBatchExpectation) Then(b1 mm_pgx.BatchResults) *TxMock {
	e.results = &TxMockSendBatchResults{b1}
	return e.mock
}

// Times sets number of times Tx.SendBatch should be invoked
func (mmSendBatch *mTxMockSendBatch) Times(n uint64) *mTxMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of TxMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	mmSendBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendBatch
}

func (mmSendBatch *mTxMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements mm_pgx.Tx
func (mmSendBatch *TxMock) SendBatch(ctx context.Context, b *mm_pgx.Batch) (b1 mm_pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	mmSendBatch.t.Helper()

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := TxMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := TxMockSendBatchParams{ctx, b}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.b != nil && !minimock.Equal(*mm_want_ptrs.b, mm_got.b) {
				mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameter b, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originB, *mm_want_ptrs.b, mm_got.b, minimock.Diff(*mm_want_ptrs.b, mm_got.b))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("TxMock.SendBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the TxMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to TxMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of TxMock.SendBatch invocations
func (mmSendBatch *TxMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to TxMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mTxMockSendBatch) Calls() []*TxMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*TxMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *TxMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *TxMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TxMock.SendBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TxMock.SendBatch at\n%s", m.SendBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TxMock.SendBatch at\n%s with params: %#v", m.SendBatchMock.defaultExpectation.expectationOrigins.origin, *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Errorf("Expected call to TxMock.SendBatch at\n%s", m.funcSendBatchOrigin)
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to TxMock.SendBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), m.SendBatchMock.expectedInvocationsOrigin, afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TxMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockCommitInspect()

			m.MinimockConnInspect()

			m.MinimockCopyFromInspect()

			m.MinimockExecInspect()

			m.MinimockLargeObjectsInspect()

			m.MinimockPrepareInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryRowInspect()

			m.MinimockRollbackInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
