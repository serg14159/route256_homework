// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.IProducer -o producer_mock.go -n IProducerMock -p mock

import (
	"context"
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IProducerMock implements mm_service.IProducer
type IProducerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcSendOutboxEvent          func(ctx context.Context, event *models.OutboxEvent) (err error)
	funcSendOutboxEventOrigin    string
	inspectFuncSendOutboxEvent   func(ctx context.Context, event *models.OutboxEvent)
	afterSendOutboxEventCounter  uint64
	beforeSendOutboxEventCounter uint64
	SendOutboxEventMock          mIProducerMockSendOutboxEvent
}

// NewIProducerMock returns a mock for mm_service.IProducer
func NewIProducerMock(t minimock.Tester) *IProducerMock {
	m := &IProducerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.SendOutboxEventMock = mIProducerMockSendOutboxEvent{mock: m}
	m.SendOutboxEventMock.callArgs = []*IProducerMockSendOutboxEventParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIProducerMockSendOutboxEvent struct {
	optional           bool
	mock               *IProducerMock
	defaultExpectation *IProducerMockSendOutboxEventExpectation
	expectations       []*IProducerMockSendOutboxEventExpectation

	callArgs []*IProducerMockSendOutboxEventParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IProducerMockSendOutboxEventExpectation specifies expectation struct of the IProducer.SendOutboxEvent
type IProducerMockSendOutboxEventExpectation struct {
	mock               *IProducerMock
	params             *IProducerMockSendOutboxEventParams
	paramPtrs          *IProducerMockSendOutboxEventParamPtrs
	expectationOrigins IProducerMockSendOutboxEventExpectationOrigins
	results            *IProducerMockSendOutboxEventResults
	returnOrigin       string
	Counter            uint64
}

// IProducerMockSendOutboxEventParams contains parameters of the IProducer.SendOutboxEvent
type IProducerMockSendOutboxEventParams struct {
	ctx   context.Context
	event *models.OutboxEvent
}

// IProducerMockSendOutboxEventParamPtrs contains pointers to parameters of the IProducer.SendOutboxEvent
type IProducerMockSendOutboxEventParamPtrs struct {
	ctx   *context.Context
	event **models.OutboxEvent
}

// IProducerMockSendOutboxEventResults contains results of the IProducer.SendOutboxEvent
type IProducerMockSendOutboxEventResults struct {
	err error
}

// IProducerMockSendOutboxEventOrigins contains origins of expectations of the IProducer.SendOutboxEvent
type IProducerMockSendOutboxEventExpectationOrigins struct {
	origin      string
	originCtx   string
	originEvent string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Optional() *mIProducerMockSendOutboxEvent {
	mmSendOutboxEvent.optional = true
	return mmSendOutboxEvent
}

// Expect sets up expected params for IProducer.SendOutboxEvent
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Expect(ctx context.Context, event *models.OutboxEvent) *mIProducerMockSendOutboxEvent {
	if mmSendOutboxEvent.mock.funcSendOutboxEvent != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Set")
	}

	if mmSendOutboxEvent.defaultExpectation == nil {
		mmSendOutboxEvent.defaultExpectation = &IProducerMockSendOutboxEventExpectation{}
	}

	if mmSendOutboxEvent.defaultExpectation.paramPtrs != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by ExpectParams functions")
	}

	mmSendOutboxEvent.defaultExpectation.params = &IProducerMockSendOutboxEventParams{ctx, event}
	mmSendOutboxEvent.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendOutboxEvent.expectations {
		if minimock.Equal(e.params, mmSendOutboxEvent.defaultExpectation.params) {
			mmSendOutboxEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendOutboxEvent.defaultExpectation.params)
		}
	}

	return mmSendOutboxEvent
}

// ExpectCtxParam1 sets up expected param ctx for IProducer.SendOutboxEvent
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) ExpectCtxParam1(ctx context.Context) *mIProducerMockSendOutboxEvent {
	if mmSendOutboxEvent.mock.funcSendOutboxEvent != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Set")
	}

	if mmSendOutboxEvent.defaultExpectation == nil {
		mmSendOutboxEvent.defaultExpectation = &IProducerMockSendOutboxEventExpectation{}
	}

	if mmSendOutboxEvent.defaultExpectation.params != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Expect")
	}

	if mmSendOutboxEvent.defaultExpectation.paramPtrs == nil {
		mmSendOutboxEvent.defaultExpectation.paramPtrs = &IProducerMockSendOutboxEventParamPtrs{}
	}
	mmSendOutboxEvent.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendOutboxEvent.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendOutboxEvent
}

// ExpectEventParam2 sets up expected param event for IProducer.SendOutboxEvent
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) ExpectEventParam2(event *models.OutboxEvent) *mIProducerMockSendOutboxEvent {
	if mmSendOutboxEvent.mock.funcSendOutboxEvent != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Set")
	}

	if mmSendOutboxEvent.defaultExpectation == nil {
		mmSendOutboxEvent.defaultExpectation = &IProducerMockSendOutboxEventExpectation{}
	}

	if mmSendOutboxEvent.defaultExpectation.params != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Expect")
	}

	if mmSendOutboxEvent.defaultExpectation.paramPtrs == nil {
		mmSendOutboxEvent.defaultExpectation.paramPtrs = &IProducerMockSendOutboxEventParamPtrs{}
	}
	mmSendOutboxEvent.defaultExpectation.paramPtrs.event = &event
	mmSendOutboxEvent.defaultExpectation.expectationOrigins.originEvent = minimock.CallerInfo(1)

	return mmSendOutboxEvent
}

// Inspect accepts an inspector function that has same arguments as the IProducer.SendOutboxEvent
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Inspect(f func(ctx context.Context, event *models.OutboxEvent)) *mIProducerMockSendOutboxEvent {
	if mmSendOutboxEvent.mock.inspectFuncSendOutboxEvent != nil {
		mmSendOutboxEvent.mock.t.Fatalf("Inspect function is already set for IProducerMock.SendOutboxEvent")
	}

	mmSendOutboxEvent.mock.inspectFuncSendOutboxEvent = f

	return mmSendOutboxEvent
}

// Return sets up results that will be returned by IProducer.SendOutboxEvent
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Return(err error) *IProducerMock {
	if mmSendOutboxEvent.mock.funcSendOutboxEvent != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Set")
	}

	if mmSendOutboxEvent.defaultExpectation == nil {
		mmSendOutboxEvent.defaultExpectation = &IProducerMockSendOutboxEventExpectation{mock: mmSendOutboxEvent.mock}
	}
	mmSendOutboxEvent.defaultExpectation.results = &IProducerMockSendOutboxEventResults{err}
	mmSendOutboxEvent.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendOutboxEvent.mock
}

// Set uses given function f to mock the IProducer.SendOutboxEvent method
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Set(f func(ctx context.Context, event *models.OutboxEvent) (err error)) *IProducerMock {
	if mmSendOutboxEvent.defaultExpectation != nil {
		mmSendOutboxEvent.mock.t.Fatalf("Default expectation is already set for the IProducer.SendOutboxEvent method")
	}

	if len(mmSendOutboxEvent.expectations) > 0 {
		mmSendOutboxEvent.mock.t.Fatalf("Some expectations are already set for the IProducer.SendOutboxEvent method")
	}

	mmSendOutboxEvent.mock.funcSendOutboxEvent = f
	mmSendOutboxEvent.mock.funcSendOutboxEventOrigin = minimock.CallerInfo(1)
	return mmSendOutboxEvent.mock
}

// When sets expectation for the IProducer.SendOutboxEvent which will trigger the result defined by the following
// Then helper
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) When(ctx context.Context, event *models.OutboxEvent) *IProducerMockSendOutboxEventExpectation {
	if mmSendOutboxEvent.mock.funcSendOutboxEvent != nil {
		mmSendOutboxEvent.mock.t.Fatalf("IProducerMock.SendOutboxEvent mock is already set by Set")
	}

	expectation := &IProducerMockSendOutboxEventExpectation{
		mock:               mmSendOutboxEvent.mock,
		params:             &IProducerMockSendOutboxEventParams{ctx, event},
		expectationOrigins: IProducerMockSendOutboxEventExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendOutboxEvent.expectations = append(mmSendOutboxEvent.expectations, expectation)
	return expectation
}

// Then sets up IProducer.SendOutboxEvent return parameters for the expectation previously defined by the When method
func (e *IProducerMockSendOutboxEventExpectation) Then(err error) *IProducerMock {
	e.results = &IProducerMockSendOutboxEventResults{err}
	return e.mock
}

// Times sets number of times IProducer.SendOutboxEvent should be invoked
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Times(n uint64) *mIProducerMockSendOutboxEvent {
	if n == 0 {
		mmSendOutboxEvent.mock.t.Fatalf("Times of IProducerMock.SendOutboxEvent mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendOutboxEvent.expectedInvocations, n)
	mmSendOutboxEvent.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendOutboxEvent
}

func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) invocationsDone() bool {
	if len(mmSendOutboxEvent.expectations) == 0 && mmSendOutboxEvent.defaultExpectation == nil && mmSendOutboxEvent.mock.funcSendOutboxEvent == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendOutboxEvent.mock.afterSendOutboxEventCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendOutboxEvent.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendOutboxEvent implements mm_service.IProducer
func (mmSendOutboxEvent *IProducerMock) SendOutboxEvent(ctx context.Context, event *models.OutboxEvent) (err error) {
	mm_atomic.AddUint64(&mmSendOutboxEvent.beforeSendOutboxEventCounter, 1)
	defer mm_atomic.AddUint64(&mmSendOutboxEvent.afterSendOutboxEventCounter, 1)

	mmSendOutboxEvent.t.Helper()

	if mmSendOutboxEvent.inspectFuncSendOutboxEvent != nil {
		mmSendOutboxEvent.inspectFuncSendOutboxEvent(ctx, event)
	}

	mm_params := IProducerMockSendOutboxEventParams{ctx, event}

	// Record call args
	mmSendOutboxEvent.SendOutboxEventMock.mutex.Lock()
	mmSendOutboxEvent.SendOutboxEventMock.callArgs = append(mmSendOutboxEvent.SendOutboxEventMock.callArgs, &mm_params)
	mmSendOutboxEvent.SendOutboxEventMock.mutex.Unlock()

	for _, e := range mmSendOutboxEvent.SendOutboxEventMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.Counter, 1)
		mm_want := mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.params
		mm_want_ptrs := mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.paramPtrs

		mm_got := IProducerMockSendOutboxEventParams{ctx, event}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendOutboxEvent.t.Errorf("IProducerMock.SendOutboxEvent got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.event != nil && !minimock.Equal(*mm_want_ptrs.event, mm_got.event) {
				mmSendOutboxEvent.t.Errorf("IProducerMock.SendOutboxEvent got unexpected parameter event, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.expectationOrigins.originEvent, *mm_want_ptrs.event, mm_got.event, minimock.Diff(*mm_want_ptrs.event, mm_got.event))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendOutboxEvent.t.Errorf("IProducerMock.SendOutboxEvent got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendOutboxEvent.SendOutboxEventMock.defaultExpectation.results
		if mm_results == nil {
			mmSendOutboxEvent.t.Fatal("No results are set for the IProducerMock.SendOutboxEvent")
		}
		return (*mm_results).err
	}
	if mmSendOutboxEvent.funcSendOutboxEvent != nil {
		return mmSendOutboxEvent.funcSendOutboxEvent(ctx, event)
	}
	mmSendOutboxEvent.t.Fatalf("Unexpected call to IProducerMock.SendOutboxEvent. %v %v", ctx, event)
	return
}

// SendOutboxEventAfterCounter returns a count of finished IProducerMock.SendOutboxEvent invocations
func (mmSendOutboxEvent *IProducerMock) SendOutboxEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendOutboxEvent.afterSendOutboxEventCounter)
}

// SendOutboxEventBeforeCounter returns a count of IProducerMock.SendOutboxEvent invocations
func (mmSendOutboxEvent *IProducerMock) SendOutboxEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendOutboxEvent.beforeSendOutboxEventCounter)
}

// Calls returns a list of arguments used in each call to IProducerMock.SendOutboxEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendOutboxEvent *mIProducerMockSendOutboxEvent) Calls() []*IProducerMockSendOutboxEventParams {
	mmSendOutboxEvent.mutex.RLock()

	argCopy := make([]*IProducerMockSendOutboxEventParams, len(mmSendOutboxEvent.callArgs))
	copy(argCopy, mmSendOutboxEvent.callArgs)

	mmSendOutboxEvent.mutex.RUnlock()

	return argCopy
}

// MinimockSendOutboxEventDone returns true if the count of the SendOutboxEvent invocations corresponds
// the number of defined expectations
func (m *IProducerMock) MinimockSendOutboxEventDone() bool {
	if m.SendOutboxEventMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendOutboxEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendOutboxEventMock.invocationsDone()
}

// MinimockSendOutboxEventInspect logs each unmet expectation
func (m *IProducerMock) MinimockSendOutboxEventInspect() {
	for _, e := range m.SendOutboxEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IProducerMock.SendOutboxEvent at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendOutboxEventCounter := mm_atomic.LoadUint64(&m.afterSendOutboxEventCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendOutboxEventMock.defaultExpectation != nil && afterSendOutboxEventCounter < 1 {
		if m.SendOutboxEventMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IProducerMock.SendOutboxEvent at\n%s", m.SendOutboxEventMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IProducerMock.SendOutboxEvent at\n%s with params: %#v", m.SendOutboxEventMock.defaultExpectation.expectationOrigins.origin, *m.SendOutboxEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendOutboxEvent != nil && afterSendOutboxEventCounter < 1 {
		m.t.Errorf("Expected call to IProducerMock.SendOutboxEvent at\n%s", m.funcSendOutboxEventOrigin)
	}

	if !m.SendOutboxEventMock.invocationsDone() && afterSendOutboxEventCounter > 0 {
		m.t.Errorf("Expected %d calls to IProducerMock.SendOutboxEvent at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendOutboxEventMock.expectedInvocations), m.SendOutboxEventMock.expectedInvocationsOrigin, afterSendOutboxEventCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IProducerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockSendOutboxEventInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IProducerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IProducerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockSendOutboxEventDone()
}
