// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.IOrderRepository -o order_repository_mock.go -n IOrderRepositoryMock -p mock

import (
	"context"
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IOrderRepositoryMock implements mm_service.IOrderRepository
type IOrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, order models.Order) (o1 models.OID, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, order models.Order)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mIOrderRepositoryMockCreate

	funcGetByID          func(ctx context.Context, orderID models.OID) (o1 models.Order, err error)
	funcGetByIDOrigin    string
	inspectFuncGetByID   func(ctx context.Context, orderID models.OID)
	afterGetByIDCounter  uint64
	beforeGetByIDCounter uint64
	GetByIDMock          mIOrderRepositoryMockGetByID

	funcSetStatus          func(ctx context.Context, orderID models.OID, status models.OrderStatus) (err error)
	funcSetStatusOrigin    string
	inspectFuncSetStatus   func(ctx context.Context, orderID models.OID, status models.OrderStatus)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mIOrderRepositoryMockSetStatus
}

// NewIOrderRepositoryMock returns a mock for mm_service.IOrderRepository
func NewIOrderRepositoryMock(t minimock.Tester) *IOrderRepositoryMock {
	m := &IOrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mIOrderRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*IOrderRepositoryMockCreateParams{}

	m.GetByIDMock = mIOrderRepositoryMockGetByID{mock: m}
	m.GetByIDMock.callArgs = []*IOrderRepositoryMockGetByIDParams{}

	m.SetStatusMock = mIOrderRepositoryMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*IOrderRepositoryMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIOrderRepositoryMockCreate struct {
	optional           bool
	mock               *IOrderRepositoryMock
	defaultExpectation *IOrderRepositoryMockCreateExpectation
	expectations       []*IOrderRepositoryMockCreateExpectation

	callArgs []*IOrderRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepositoryMockCreateExpectation specifies expectation struct of the IOrderRepository.Create
type IOrderRepositoryMockCreateExpectation struct {
	mock               *IOrderRepositoryMock
	params             *IOrderRepositoryMockCreateParams
	paramPtrs          *IOrderRepositoryMockCreateParamPtrs
	expectationOrigins IOrderRepositoryMockCreateExpectationOrigins
	results            *IOrderRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepositoryMockCreateParams contains parameters of the IOrderRepository.Create
type IOrderRepositoryMockCreateParams struct {
	ctx   context.Context
	order models.Order
}

// IOrderRepositoryMockCreateParamPtrs contains pointers to parameters of the IOrderRepository.Create
type IOrderRepositoryMockCreateParamPtrs struct {
	ctx   *context.Context
	order *models.Order
}

// IOrderRepositoryMockCreateResults contains results of the IOrderRepository.Create
type IOrderRepositoryMockCreateResults struct {
	o1  models.OID
	err error
}

// IOrderRepositoryMockCreateOrigins contains origins of expectations of the IOrderRepository.Create
type IOrderRepositoryMockCreateExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mIOrderRepositoryMockCreate) Optional() *mIOrderRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for IOrderRepository.Create
func (mmCreate *mIOrderRepositoryMockCreate) Expect(ctx context.Context, order models.Order) *mIOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &IOrderRepositoryMockCreateParams{ctx, order}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepository.Create
func (mmCreate *mIOrderRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mIOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &IOrderRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectOrderParam2 sets up expected param order for IOrderRepository.Create
func (mmCreate *mIOrderRepositoryMockCreate) ExpectOrderParam2(order models.Order) *mIOrderRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &IOrderRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.order = &order
	mmCreate.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepository.Create
func (mmCreate *mIOrderRepositoryMockCreate) Inspect(f func(ctx context.Context, order models.Order)) *mIOrderRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for IOrderRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by IOrderRepository.Create
func (mmCreate *mIOrderRepositoryMockCreate) Return(o1 models.OID, err error) *IOrderRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &IOrderRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &IOrderRepositoryMockCreateResults{o1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the IOrderRepository.Create method
func (mmCreate *mIOrderRepositoryMockCreate) Set(f func(ctx context.Context, order models.Order) (o1 models.OID, err error)) *IOrderRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the IOrderRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the IOrderRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the IOrderRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mIOrderRepositoryMockCreate) When(ctx context.Context, order models.Order) *IOrderRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("IOrderRepositoryMock.Create mock is already set by Set")
	}

	expectation := &IOrderRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &IOrderRepositoryMockCreateParams{ctx, order},
		expectationOrigins: IOrderRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepository.Create return parameters for the expectation previously defined by the When method
func (e *IOrderRepositoryMockCreateExpectation) Then(o1 models.OID, err error) *IOrderRepositoryMock {
	e.results = &IOrderRepositoryMockCreateResults{o1, err}
	return e.mock
}

// Times sets number of times IOrderRepository.Create should be invoked
func (mmCreate *mIOrderRepositoryMockCreate) Times(n uint64) *mIOrderRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of IOrderRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mIOrderRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.IOrderRepository
func (mmCreate *IOrderRepositoryMock) Create(ctx context.Context, order models.Order) (o1 models.OID, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, order)
	}

	mm_params := IOrderRepositoryMockCreateParams{ctx, order}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepositoryMockCreateParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("IOrderRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreate.t.Errorf("IOrderRepositoryMock.Create got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("IOrderRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the IOrderRepositoryMock.Create")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, order)
	}
	mmCreate.t.Fatalf("Unexpected call to IOrderRepositoryMock.Create. %v %v", ctx, order)
	return
}

// CreateAfterCounter returns a count of finished IOrderRepositoryMock.Create invocations
func (mmCreate *IOrderRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of IOrderRepositoryMock.Create invocations
func (mmCreate *IOrderRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mIOrderRepositoryMockCreate) Calls() []*IOrderRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*IOrderRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *IOrderRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *IOrderRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mIOrderRepositoryMockGetByID struct {
	optional           bool
	mock               *IOrderRepositoryMock
	defaultExpectation *IOrderRepositoryMockGetByIDExpectation
	expectations       []*IOrderRepositoryMockGetByIDExpectation

	callArgs []*IOrderRepositoryMockGetByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepositoryMockGetByIDExpectation specifies expectation struct of the IOrderRepository.GetByID
type IOrderRepositoryMockGetByIDExpectation struct {
	mock               *IOrderRepositoryMock
	params             *IOrderRepositoryMockGetByIDParams
	paramPtrs          *IOrderRepositoryMockGetByIDParamPtrs
	expectationOrigins IOrderRepositoryMockGetByIDExpectationOrigins
	results            *IOrderRepositoryMockGetByIDResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepositoryMockGetByIDParams contains parameters of the IOrderRepository.GetByID
type IOrderRepositoryMockGetByIDParams struct {
	ctx     context.Context
	orderID models.OID
}

// IOrderRepositoryMockGetByIDParamPtrs contains pointers to parameters of the IOrderRepository.GetByID
type IOrderRepositoryMockGetByIDParamPtrs struct {
	ctx     *context.Context
	orderID *models.OID
}

// IOrderRepositoryMockGetByIDResults contains results of the IOrderRepository.GetByID
type IOrderRepositoryMockGetByIDResults struct {
	o1  models.Order
	err error
}

// IOrderRepositoryMockGetByIDOrigins contains origins of expectations of the IOrderRepository.GetByID
type IOrderRepositoryMockGetByIDExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByID *mIOrderRepositoryMockGetByID) Optional() *mIOrderRepositoryMockGetByID {
	mmGetByID.optional = true
	return mmGetByID
}

// Expect sets up expected params for IOrderRepository.GetByID
func (mmGetByID *mIOrderRepositoryMockGetByID) Expect(ctx context.Context, orderID models.OID) *mIOrderRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &IOrderRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.paramPtrs != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by ExpectParams functions")
	}

	mmGetByID.defaultExpectation.params = &IOrderRepositoryMockGetByIDParams{ctx, orderID}
	mmGetByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByID.expectations {
		if minimock.Equal(e.params, mmGetByID.defaultExpectation.params) {
			mmGetByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByID.defaultExpectation.params)
		}
	}

	return mmGetByID
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepository.GetByID
func (mmGetByID *mIOrderRepositoryMockGetByID) ExpectCtxParam1(ctx context.Context) *mIOrderRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &IOrderRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &IOrderRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByID
}

// ExpectOrderIDParam2 sets up expected param orderID for IOrderRepository.GetByID
func (mmGetByID *mIOrderRepositoryMockGetByID) ExpectOrderIDParam2(orderID models.OID) *mIOrderRepositoryMockGetByID {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &IOrderRepositoryMockGetByIDExpectation{}
	}

	if mmGetByID.defaultExpectation.params != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Expect")
	}

	if mmGetByID.defaultExpectation.paramPtrs == nil {
		mmGetByID.defaultExpectation.paramPtrs = &IOrderRepositoryMockGetByIDParamPtrs{}
	}
	mmGetByID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetByID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetByID
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepository.GetByID
func (mmGetByID *mIOrderRepositoryMockGetByID) Inspect(f func(ctx context.Context, orderID models.OID)) *mIOrderRepositoryMockGetByID {
	if mmGetByID.mock.inspectFuncGetByID != nil {
		mmGetByID.mock.t.Fatalf("Inspect function is already set for IOrderRepositoryMock.GetByID")
	}

	mmGetByID.mock.inspectFuncGetByID = f

	return mmGetByID
}

// Return sets up results that will be returned by IOrderRepository.GetByID
func (mmGetByID *mIOrderRepositoryMockGetByID) Return(o1 models.Order, err error) *IOrderRepositoryMock {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Set")
	}

	if mmGetByID.defaultExpectation == nil {
		mmGetByID.defaultExpectation = &IOrderRepositoryMockGetByIDExpectation{mock: mmGetByID.mock}
	}
	mmGetByID.defaultExpectation.results = &IOrderRepositoryMockGetByIDResults{o1, err}
	mmGetByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// Set uses given function f to mock the IOrderRepository.GetByID method
func (mmGetByID *mIOrderRepositoryMockGetByID) Set(f func(ctx context.Context, orderID models.OID) (o1 models.Order, err error)) *IOrderRepositoryMock {
	if mmGetByID.defaultExpectation != nil {
		mmGetByID.mock.t.Fatalf("Default expectation is already set for the IOrderRepository.GetByID method")
	}

	if len(mmGetByID.expectations) > 0 {
		mmGetByID.mock.t.Fatalf("Some expectations are already set for the IOrderRepository.GetByID method")
	}

	mmGetByID.mock.funcGetByID = f
	mmGetByID.mock.funcGetByIDOrigin = minimock.CallerInfo(1)
	return mmGetByID.mock
}

// When sets expectation for the IOrderRepository.GetByID which will trigger the result defined by the following
// Then helper
func (mmGetByID *mIOrderRepositoryMockGetByID) When(ctx context.Context, orderID models.OID) *IOrderRepositoryMockGetByIDExpectation {
	if mmGetByID.mock.funcGetByID != nil {
		mmGetByID.mock.t.Fatalf("IOrderRepositoryMock.GetByID mock is already set by Set")
	}

	expectation := &IOrderRepositoryMockGetByIDExpectation{
		mock:               mmGetByID.mock,
		params:             &IOrderRepositoryMockGetByIDParams{ctx, orderID},
		expectationOrigins: IOrderRepositoryMockGetByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByID.expectations = append(mmGetByID.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepository.GetByID return parameters for the expectation previously defined by the When method
func (e *IOrderRepositoryMockGetByIDExpectation) Then(o1 models.Order, err error) *IOrderRepositoryMock {
	e.results = &IOrderRepositoryMockGetByIDResults{o1, err}
	return e.mock
}

// Times sets number of times IOrderRepository.GetByID should be invoked
func (mmGetByID *mIOrderRepositoryMockGetByID) Times(n uint64) *mIOrderRepositoryMockGetByID {
	if n == 0 {
		mmGetByID.mock.t.Fatalf("Times of IOrderRepositoryMock.GetByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByID.expectedInvocations, n)
	mmGetByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByID
}

func (mmGetByID *mIOrderRepositoryMockGetByID) invocationsDone() bool {
	if len(mmGetByID.expectations) == 0 && mmGetByID.defaultExpectation == nil && mmGetByID.mock.funcGetByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByID.mock.afterGetByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByID implements mm_service.IOrderRepository
func (mmGetByID *IOrderRepositoryMock) GetByID(ctx context.Context, orderID models.OID) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmGetByID.beforeGetByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByID.afterGetByIDCounter, 1)

	mmGetByID.t.Helper()

	if mmGetByID.inspectFuncGetByID != nil {
		mmGetByID.inspectFuncGetByID(ctx, orderID)
	}

	mm_params := IOrderRepositoryMockGetByIDParams{ctx, orderID}

	// Record call args
	mmGetByID.GetByIDMock.mutex.Lock()
	mmGetByID.GetByIDMock.callArgs = append(mmGetByID.GetByIDMock.callArgs, &mm_params)
	mmGetByID.GetByIDMock.mutex.Unlock()

	for _, e := range mmGetByID.GetByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetByID.GetByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByID.GetByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByID.GetByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByID.GetByIDMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepositoryMockGetByIDParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByID.t.Errorf("IOrderRepositoryMock.GetByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByID.t.Errorf("IOrderRepositoryMock.GetByID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByID.t.Errorf("IOrderRepositoryMock.GetByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByID.GetByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByID.GetByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByID.t.Fatal("No results are set for the IOrderRepositoryMock.GetByID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetByID.funcGetByID != nil {
		return mmGetByID.funcGetByID(ctx, orderID)
	}
	mmGetByID.t.Fatalf("Unexpected call to IOrderRepositoryMock.GetByID. %v %v", ctx, orderID)
	return
}

// GetByIDAfterCounter returns a count of finished IOrderRepositoryMock.GetByID invocations
func (mmGetByID *IOrderRepositoryMock) GetByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.afterGetByIDCounter)
}

// GetByIDBeforeCounter returns a count of IOrderRepositoryMock.GetByID invocations
func (mmGetByID *IOrderRepositoryMock) GetByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByID.beforeGetByIDCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepositoryMock.GetByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByID *mIOrderRepositoryMockGetByID) Calls() []*IOrderRepositoryMockGetByIDParams {
	mmGetByID.mutex.RLock()

	argCopy := make([]*IOrderRepositoryMockGetByIDParams, len(mmGetByID.callArgs))
	copy(argCopy, mmGetByID.callArgs)

	mmGetByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIDDone returns true if the count of the GetByID invocations corresponds
// the number of defined expectations
func (m *IOrderRepositoryMock) MinimockGetByIDDone() bool {
	if m.GetByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIDMock.invocationsDone()
}

// MinimockGetByIDInspect logs each unmet expectation
func (m *IOrderRepositoryMock) MinimockGetByIDInspect() {
	for _, e := range m.GetByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepositoryMock.GetByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIDCounter := mm_atomic.LoadUint64(&m.afterGetByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIDMock.defaultExpectation != nil && afterGetByIDCounter < 1 {
		if m.GetByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepositoryMock.GetByID at\n%s", m.GetByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepositoryMock.GetByID at\n%s with params: %#v", m.GetByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByID != nil && afterGetByIDCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepositoryMock.GetByID at\n%s", m.funcGetByIDOrigin)
	}

	if !m.GetByIDMock.invocationsDone() && afterGetByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepositoryMock.GetByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIDMock.expectedInvocations), m.GetByIDMock.expectedInvocationsOrigin, afterGetByIDCounter)
	}
}

type mIOrderRepositoryMockSetStatus struct {
	optional           bool
	mock               *IOrderRepositoryMock
	defaultExpectation *IOrderRepositoryMockSetStatusExpectation
	expectations       []*IOrderRepositoryMockSetStatusExpectation

	callArgs []*IOrderRepositoryMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepositoryMockSetStatusExpectation specifies expectation struct of the IOrderRepository.SetStatus
type IOrderRepositoryMockSetStatusExpectation struct {
	mock               *IOrderRepositoryMock
	params             *IOrderRepositoryMockSetStatusParams
	paramPtrs          *IOrderRepositoryMockSetStatusParamPtrs
	expectationOrigins IOrderRepositoryMockSetStatusExpectationOrigins
	results            *IOrderRepositoryMockSetStatusResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepositoryMockSetStatusParams contains parameters of the IOrderRepository.SetStatus
type IOrderRepositoryMockSetStatusParams struct {
	ctx     context.Context
	orderID models.OID
	status  models.OrderStatus
}

// IOrderRepositoryMockSetStatusParamPtrs contains pointers to parameters of the IOrderRepository.SetStatus
type IOrderRepositoryMockSetStatusParamPtrs struct {
	ctx     *context.Context
	orderID *models.OID
	status  *models.OrderStatus
}

// IOrderRepositoryMockSetStatusResults contains results of the IOrderRepository.SetStatus
type IOrderRepositoryMockSetStatusResults struct {
	err error
}

// IOrderRepositoryMockSetStatusOrigins contains origins of expectations of the IOrderRepository.SetStatus
type IOrderRepositoryMockSetStatusExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Optional() *mIOrderRepositoryMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for IOrderRepository.SetStatus
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Expect(ctx context.Context, orderID models.OID, status models.OrderStatus) *mIOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &IOrderRepositoryMockSetStatusParams{ctx, orderID, status}
	mmSetStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepository.SetStatus
func (mmSetStatus *mIOrderRepositoryMockSetStatus) ExpectCtxParam1(ctx context.Context) *mIOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &IOrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetStatus.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectOrderIDParam2 sets up expected param orderID for IOrderRepository.SetStatus
func (mmSetStatus *mIOrderRepositoryMockSetStatus) ExpectOrderIDParam2(orderID models.OID) *mIOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &IOrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for IOrderRepository.SetStatus
func (mmSetStatus *mIOrderRepositoryMockSetStatus) ExpectStatusParam3(status models.OrderStatus) *mIOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderRepositoryMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &IOrderRepositoryMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status
	mmSetStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepository.SetStatus
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Inspect(f func(ctx context.Context, orderID models.OID, status models.OrderStatus)) *mIOrderRepositoryMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for IOrderRepositoryMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by IOrderRepository.SetStatus
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Return(err error) *IOrderRepositoryMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &IOrderRepositoryMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &IOrderRepositoryMockSetStatusResults{err}
	mmSetStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// Set uses given function f to mock the IOrderRepository.SetStatus method
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Set(f func(ctx context.Context, orderID models.OID, status models.OrderStatus) (err error)) *IOrderRepositoryMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the IOrderRepository.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the IOrderRepository.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	mmSetStatus.mock.funcSetStatusOrigin = minimock.CallerInfo(1)
	return mmSetStatus.mock
}

// When sets expectation for the IOrderRepository.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mIOrderRepositoryMockSetStatus) When(ctx context.Context, orderID models.OID, status models.OrderStatus) *IOrderRepositoryMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("IOrderRepositoryMock.SetStatus mock is already set by Set")
	}

	expectation := &IOrderRepositoryMockSetStatusExpectation{
		mock:               mmSetStatus.mock,
		params:             &IOrderRepositoryMockSetStatusParams{ctx, orderID, status},
		expectationOrigins: IOrderRepositoryMockSetStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepository.SetStatus return parameters for the expectation previously defined by the When method
func (e *IOrderRepositoryMockSetStatusExpectation) Then(err error) *IOrderRepositoryMock {
	e.results = &IOrderRepositoryMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times IOrderRepository.SetStatus should be invoked
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Times(n uint64) *mIOrderRepositoryMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of IOrderRepositoryMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	mmSetStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStatus
}

func (mmSetStatus *mIOrderRepositoryMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements mm_service.IOrderRepository
func (mmSetStatus *IOrderRepositoryMock) SetStatus(ctx context.Context, orderID models.OID, status models.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	mmSetStatus.t.Helper()

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, orderID, status)
	}

	mm_params := IOrderRepositoryMockSetStatusParams{ctx, orderID, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepositoryMockSetStatusParams{ctx, orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("IOrderRepositoryMock.SetStatus got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetStatus.t.Errorf("IOrderRepositoryMock.SetStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("IOrderRepositoryMock.SetStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("IOrderRepositoryMock.SetStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStatus.SetStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the IOrderRepositoryMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, orderID, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to IOrderRepositoryMock.SetStatus. %v %v %v", ctx, orderID, status)
	return
}

// SetStatusAfterCounter returns a count of finished IOrderRepositoryMock.SetStatus invocations
func (mmSetStatus *IOrderRepositoryMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of IOrderRepositoryMock.SetStatus invocations
func (mmSetStatus *IOrderRepositoryMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepositoryMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mIOrderRepositoryMockSetStatus) Calls() []*IOrderRepositoryMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*IOrderRepositoryMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *IOrderRepositoryMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *IOrderRepositoryMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepositoryMock.SetStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepositoryMock.SetStatus at\n%s", m.SetStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepositoryMock.SetStatus at\n%s with params: %#v", m.SetStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepositoryMock.SetStatus at\n%s", m.funcSetStatusOrigin)
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepositoryMock.SetStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), m.SetStatusMock.expectedInvocationsOrigin, afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockGetByIDInspect()

			m.MinimockSetStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockGetByIDDone() &&
		m.MinimockSetStatusDone()
}
