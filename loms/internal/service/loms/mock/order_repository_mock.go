// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i route256/loms/internal/service/loms.IOrderRepository -o order_repository_mock.go -n IOrderRepositoryMock -p mock

import (
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IOrderRepositoryMock implements mm_service.IOrderRepository
type IOrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(order models.Order) (i1 int64, err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(order models.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mIOrderRepositoryMockCreateOrder

	funcGetByOrderID          func(orderID models.OID) (o1 models.Order, err error)
	funcGetByOrderIDOrigin    string
	inspectFuncGetByOrderID   func(orderID models.OID)
	afterGetByOrderIDCounter  uint64
	beforeGetByOrderIDCounter uint64
	GetByOrderIDMock          mIOrderRepositoryMockGetByOrderID

	funcSetOrderStatus          func(orderID models.OID, status models.OrderStatus) (err error)
	funcSetOrderStatusOrigin    string
	inspectFuncSetOrderStatus   func(orderID models.OID, status models.OrderStatus)
	afterSetOrderStatusCounter  uint64
	beforeSetOrderStatusCounter uint64
	SetOrderStatusMock          mIOrderRepositoryMockSetOrderStatus
}

// NewIOrderRepositoryMock returns a mock for mm_service.IOrderRepository
func NewIOrderRepositoryMock(t minimock.Tester) *IOrderRepositoryMock {
	m := &IOrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mIOrderRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*IOrderRepositoryMockCreateOrderParams{}

	m.GetByOrderIDMock = mIOrderRepositoryMockGetByOrderID{mock: m}
	m.GetByOrderIDMock.callArgs = []*IOrderRepositoryMockGetByOrderIDParams{}

	m.SetOrderStatusMock = mIOrderRepositoryMockSetOrderStatus{mock: m}
	m.SetOrderStatusMock.callArgs = []*IOrderRepositoryMockSetOrderStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mIOrderRepositoryMockCreateOrder struct {
	optional           bool
	mock               *IOrderRepositoryMock
	defaultExpectation *IOrderRepositoryMockCreateOrderExpectation
	expectations       []*IOrderRepositoryMockCreateOrderExpectation

	callArgs []*IOrderRepositoryMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepositoryMockCreateOrderExpectation specifies expectation struct of the IOrderRepository.CreateOrder
type IOrderRepositoryMockCreateOrderExpectation struct {
	mock               *IOrderRepositoryMock
	params             *IOrderRepositoryMockCreateOrderParams
	paramPtrs          *IOrderRepositoryMockCreateOrderParamPtrs
	expectationOrigins IOrderRepositoryMockCreateOrderExpectationOrigins
	results            *IOrderRepositoryMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepositoryMockCreateOrderParams contains parameters of the IOrderRepository.CreateOrder
type IOrderRepositoryMockCreateOrderParams struct {
	order models.Order
}

// IOrderRepositoryMockCreateOrderParamPtrs contains pointers to parameters of the IOrderRepository.CreateOrder
type IOrderRepositoryMockCreateOrderParamPtrs struct {
	order *models.Order
}

// IOrderRepositoryMockCreateOrderResults contains results of the IOrderRepository.CreateOrder
type IOrderRepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// IOrderRepositoryMockCreateOrderOrigins contains origins of expectations of the IOrderRepository.CreateOrder
type IOrderRepositoryMockCreateOrderExpectationOrigins struct {
	origin      string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Optional() *mIOrderRepositoryMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for IOrderRepository.CreateOrder
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Expect(order models.Order) *mIOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepositoryMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &IOrderRepositoryMockCreateOrderParams{order}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectOrderParam1 sets up expected param order for IOrderRepository.CreateOrder
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) ExpectOrderParam1(order models.Order) *mIOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepositoryMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepositoryMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &IOrderRepositoryMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.order = &order
	mmCreateOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepository.CreateOrder
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Inspect(f func(order models.Order)) *mIOrderRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for IOrderRepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by IOrderRepository.CreateOrder
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Return(i1 int64, err error) *IOrderRepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &IOrderRepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &IOrderRepositoryMockCreateOrderResults{i1, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the IOrderRepository.CreateOrder method
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Set(f func(order models.Order) (i1 int64, err error)) *IOrderRepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the IOrderRepository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) When(order models.Order) *IOrderRepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("IOrderRepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &IOrderRepositoryMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &IOrderRepositoryMockCreateOrderParams{order},
		expectationOrigins: IOrderRepositoryMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *IOrderRepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *IOrderRepositoryMock {
	e.results = &IOrderRepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// Times sets number of times IOrderRepository.CreateOrder should be invoked
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Times(n uint64) *mIOrderRepositoryMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of IOrderRepositoryMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_service.IOrderRepository
func (mmCreateOrder *IOrderRepositoryMock) CreateOrder(order models.Order) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(order)
	}

	mm_params := IOrderRepositoryMockCreateOrderParams{order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepositoryMockCreateOrderParams{order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmCreateOrder.t.Errorf("IOrderRepositoryMock.CreateOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("IOrderRepositoryMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the IOrderRepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to IOrderRepositoryMock.CreateOrder. %v", order)
	return
}

// CreateOrderAfterCounter returns a count of finished IOrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *IOrderRepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of IOrderRepositoryMock.CreateOrder invocations
func (mmCreateOrder *IOrderRepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mIOrderRepositoryMockCreateOrder) Calls() []*IOrderRepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*IOrderRepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *IOrderRepositoryMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *IOrderRepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepositoryMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepositoryMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepositoryMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepositoryMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepositoryMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mIOrderRepositoryMockGetByOrderID struct {
	optional           bool
	mock               *IOrderRepositoryMock
	defaultExpectation *IOrderRepositoryMockGetByOrderIDExpectation
	expectations       []*IOrderRepositoryMockGetByOrderIDExpectation

	callArgs []*IOrderRepositoryMockGetByOrderIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepositoryMockGetByOrderIDExpectation specifies expectation struct of the IOrderRepository.GetByOrderID
type IOrderRepositoryMockGetByOrderIDExpectation struct {
	mock               *IOrderRepositoryMock
	params             *IOrderRepositoryMockGetByOrderIDParams
	paramPtrs          *IOrderRepositoryMockGetByOrderIDParamPtrs
	expectationOrigins IOrderRepositoryMockGetByOrderIDExpectationOrigins
	results            *IOrderRepositoryMockGetByOrderIDResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepositoryMockGetByOrderIDParams contains parameters of the IOrderRepository.GetByOrderID
type IOrderRepositoryMockGetByOrderIDParams struct {
	orderID models.OID
}

// IOrderRepositoryMockGetByOrderIDParamPtrs contains pointers to parameters of the IOrderRepository.GetByOrderID
type IOrderRepositoryMockGetByOrderIDParamPtrs struct {
	orderID *models.OID
}

// IOrderRepositoryMockGetByOrderIDResults contains results of the IOrderRepository.GetByOrderID
type IOrderRepositoryMockGetByOrderIDResults struct {
	o1  models.Order
	err error
}

// IOrderRepositoryMockGetByOrderIDOrigins contains origins of expectations of the IOrderRepository.GetByOrderID
type IOrderRepositoryMockGetByOrderIDExpectationOrigins struct {
	origin        string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Optional() *mIOrderRepositoryMockGetByOrderID {
	mmGetByOrderID.optional = true
	return mmGetByOrderID
}

// Expect sets up expected params for IOrderRepository.GetByOrderID
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Expect(orderID models.OID) *mIOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("IOrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &IOrderRepositoryMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs != nil {
		mmGetByOrderID.mock.t.Fatalf("IOrderRepositoryMock.GetByOrderID mock is already set by ExpectParams functions")
	}

	mmGetByOrderID.defaultExpectation.params = &IOrderRepositoryMockGetByOrderIDParams{orderID}
	mmGetByOrderID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByOrderID.expectations {
		if minimock.Equal(e.params, mmGetByOrderID.defaultExpectation.params) {
			mmGetByOrderID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByOrderID.defaultExpectation.params)
		}
	}

	return mmGetByOrderID
}

// ExpectOrderIDParam1 sets up expected param orderID for IOrderRepository.GetByOrderID
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) ExpectOrderIDParam1(orderID models.OID) *mIOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("IOrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &IOrderRepositoryMockGetByOrderIDExpectation{}
	}

	if mmGetByOrderID.defaultExpectation.params != nil {
		mmGetByOrderID.mock.t.Fatalf("IOrderRepositoryMock.GetByOrderID mock is already set by Expect")
	}

	if mmGetByOrderID.defaultExpectation.paramPtrs == nil {
		mmGetByOrderID.defaultExpectation.paramPtrs = &IOrderRepositoryMockGetByOrderIDParamPtrs{}
	}
	mmGetByOrderID.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetByOrderID.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetByOrderID
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepository.GetByOrderID
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Inspect(f func(orderID models.OID)) *mIOrderRepositoryMockGetByOrderID {
	if mmGetByOrderID.mock.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("Inspect function is already set for IOrderRepositoryMock.GetByOrderID")
	}

	mmGetByOrderID.mock.inspectFuncGetByOrderID = f

	return mmGetByOrderID
}

// Return sets up results that will be returned by IOrderRepository.GetByOrderID
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Return(o1 models.Order, err error) *IOrderRepositoryMock {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("IOrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	if mmGetByOrderID.defaultExpectation == nil {
		mmGetByOrderID.defaultExpectation = &IOrderRepositoryMockGetByOrderIDExpectation{mock: mmGetByOrderID.mock}
	}
	mmGetByOrderID.defaultExpectation.results = &IOrderRepositoryMockGetByOrderIDResults{o1, err}
	mmGetByOrderID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID.mock
}

// Set uses given function f to mock the IOrderRepository.GetByOrderID method
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Set(f func(orderID models.OID) (o1 models.Order, err error)) *IOrderRepositoryMock {
	if mmGetByOrderID.defaultExpectation != nil {
		mmGetByOrderID.mock.t.Fatalf("Default expectation is already set for the IOrderRepository.GetByOrderID method")
	}

	if len(mmGetByOrderID.expectations) > 0 {
		mmGetByOrderID.mock.t.Fatalf("Some expectations are already set for the IOrderRepository.GetByOrderID method")
	}

	mmGetByOrderID.mock.funcGetByOrderID = f
	mmGetByOrderID.mock.funcGetByOrderIDOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID.mock
}

// When sets expectation for the IOrderRepository.GetByOrderID which will trigger the result defined by the following
// Then helper
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) When(orderID models.OID) *IOrderRepositoryMockGetByOrderIDExpectation {
	if mmGetByOrderID.mock.funcGetByOrderID != nil {
		mmGetByOrderID.mock.t.Fatalf("IOrderRepositoryMock.GetByOrderID mock is already set by Set")
	}

	expectation := &IOrderRepositoryMockGetByOrderIDExpectation{
		mock:               mmGetByOrderID.mock,
		params:             &IOrderRepositoryMockGetByOrderIDParams{orderID},
		expectationOrigins: IOrderRepositoryMockGetByOrderIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByOrderID.expectations = append(mmGetByOrderID.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepository.GetByOrderID return parameters for the expectation previously defined by the When method
func (e *IOrderRepositoryMockGetByOrderIDExpectation) Then(o1 models.Order, err error) *IOrderRepositoryMock {
	e.results = &IOrderRepositoryMockGetByOrderIDResults{o1, err}
	return e.mock
}

// Times sets number of times IOrderRepository.GetByOrderID should be invoked
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Times(n uint64) *mIOrderRepositoryMockGetByOrderID {
	if n == 0 {
		mmGetByOrderID.mock.t.Fatalf("Times of IOrderRepositoryMock.GetByOrderID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByOrderID.expectedInvocations, n)
	mmGetByOrderID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByOrderID
}

func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) invocationsDone() bool {
	if len(mmGetByOrderID.expectations) == 0 && mmGetByOrderID.defaultExpectation == nil && mmGetByOrderID.mock.funcGetByOrderID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.mock.afterGetByOrderIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByOrderID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByOrderID implements mm_service.IOrderRepository
func (mmGetByOrderID *IOrderRepositoryMock) GetByOrderID(orderID models.OID) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmGetByOrderID.beforeGetByOrderIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByOrderID.afterGetByOrderIDCounter, 1)

	mmGetByOrderID.t.Helper()

	if mmGetByOrderID.inspectFuncGetByOrderID != nil {
		mmGetByOrderID.inspectFuncGetByOrderID(orderID)
	}

	mm_params := IOrderRepositoryMockGetByOrderIDParams{orderID}

	// Record call args
	mmGetByOrderID.GetByOrderIDMock.mutex.Lock()
	mmGetByOrderID.GetByOrderIDMock.callArgs = append(mmGetByOrderID.GetByOrderIDMock.callArgs, &mm_params)
	mmGetByOrderID.GetByOrderIDMock.mutex.Unlock()

	for _, e := range mmGetByOrderID.GetByOrderIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetByOrderID.GetByOrderIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByOrderID.GetByOrderIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepositoryMockGetByOrderIDParams{orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetByOrderID.t.Errorf("IOrderRepositoryMock.GetByOrderID got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByOrderID.t.Errorf("IOrderRepositoryMock.GetByOrderID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByOrderID.GetByOrderIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByOrderID.GetByOrderIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByOrderID.t.Fatal("No results are set for the IOrderRepositoryMock.GetByOrderID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetByOrderID.funcGetByOrderID != nil {
		return mmGetByOrderID.funcGetByOrderID(orderID)
	}
	mmGetByOrderID.t.Fatalf("Unexpected call to IOrderRepositoryMock.GetByOrderID. %v", orderID)
	return
}

// GetByOrderIDAfterCounter returns a count of finished IOrderRepositoryMock.GetByOrderID invocations
func (mmGetByOrderID *IOrderRepositoryMock) GetByOrderIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.afterGetByOrderIDCounter)
}

// GetByOrderIDBeforeCounter returns a count of IOrderRepositoryMock.GetByOrderID invocations
func (mmGetByOrderID *IOrderRepositoryMock) GetByOrderIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByOrderID.beforeGetByOrderIDCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepositoryMock.GetByOrderID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByOrderID *mIOrderRepositoryMockGetByOrderID) Calls() []*IOrderRepositoryMockGetByOrderIDParams {
	mmGetByOrderID.mutex.RLock()

	argCopy := make([]*IOrderRepositoryMockGetByOrderIDParams, len(mmGetByOrderID.callArgs))
	copy(argCopy, mmGetByOrderID.callArgs)

	mmGetByOrderID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByOrderIDDone returns true if the count of the GetByOrderID invocations corresponds
// the number of defined expectations
func (m *IOrderRepositoryMock) MinimockGetByOrderIDDone() bool {
	if m.GetByOrderIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByOrderIDMock.invocationsDone()
}

// MinimockGetByOrderIDInspect logs each unmet expectation
func (m *IOrderRepositoryMock) MinimockGetByOrderIDInspect() {
	for _, e := range m.GetByOrderIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepositoryMock.GetByOrderID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByOrderIDCounter := mm_atomic.LoadUint64(&m.afterGetByOrderIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByOrderIDMock.defaultExpectation != nil && afterGetByOrderIDCounter < 1 {
		if m.GetByOrderIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepositoryMock.GetByOrderID at\n%s", m.GetByOrderIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepositoryMock.GetByOrderID at\n%s with params: %#v", m.GetByOrderIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByOrderIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByOrderID != nil && afterGetByOrderIDCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepositoryMock.GetByOrderID at\n%s", m.funcGetByOrderIDOrigin)
	}

	if !m.GetByOrderIDMock.invocationsDone() && afterGetByOrderIDCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepositoryMock.GetByOrderID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByOrderIDMock.expectedInvocations), m.GetByOrderIDMock.expectedInvocationsOrigin, afterGetByOrderIDCounter)
	}
}

type mIOrderRepositoryMockSetOrderStatus struct {
	optional           bool
	mock               *IOrderRepositoryMock
	defaultExpectation *IOrderRepositoryMockSetOrderStatusExpectation
	expectations       []*IOrderRepositoryMockSetOrderStatusExpectation

	callArgs []*IOrderRepositoryMockSetOrderStatusParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// IOrderRepositoryMockSetOrderStatusExpectation specifies expectation struct of the IOrderRepository.SetOrderStatus
type IOrderRepositoryMockSetOrderStatusExpectation struct {
	mock               *IOrderRepositoryMock
	params             *IOrderRepositoryMockSetOrderStatusParams
	paramPtrs          *IOrderRepositoryMockSetOrderStatusParamPtrs
	expectationOrigins IOrderRepositoryMockSetOrderStatusExpectationOrigins
	results            *IOrderRepositoryMockSetOrderStatusResults
	returnOrigin       string
	Counter            uint64
}

// IOrderRepositoryMockSetOrderStatusParams contains parameters of the IOrderRepository.SetOrderStatus
type IOrderRepositoryMockSetOrderStatusParams struct {
	orderID models.OID
	status  models.OrderStatus
}

// IOrderRepositoryMockSetOrderStatusParamPtrs contains pointers to parameters of the IOrderRepository.SetOrderStatus
type IOrderRepositoryMockSetOrderStatusParamPtrs struct {
	orderID *models.OID
	status  *models.OrderStatus
}

// IOrderRepositoryMockSetOrderStatusResults contains results of the IOrderRepository.SetOrderStatus
type IOrderRepositoryMockSetOrderStatusResults struct {
	err error
}

// IOrderRepositoryMockSetOrderStatusOrigins contains origins of expectations of the IOrderRepository.SetOrderStatus
type IOrderRepositoryMockSetOrderStatusExpectationOrigins struct {
	origin        string
	originOrderID string
	originStatus  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Optional() *mIOrderRepositoryMockSetOrderStatus {
	mmSetOrderStatus.optional = true
	return mmSetOrderStatus
}

// Expect sets up expected params for IOrderRepository.SetOrderStatus
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Expect(orderID models.OID, status models.OrderStatus) *mIOrderRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &IOrderRepositoryMockSetOrderStatusExpectation{}
	}

	if mmSetOrderStatus.defaultExpectation.paramPtrs != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by ExpectParams functions")
	}

	mmSetOrderStatus.defaultExpectation.params = &IOrderRepositoryMockSetOrderStatusParams{orderID, status}
	mmSetOrderStatus.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOrderStatus.expectations {
		if minimock.Equal(e.params, mmSetOrderStatus.defaultExpectation.params) {
			mmSetOrderStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOrderStatus.defaultExpectation.params)
		}
	}

	return mmSetOrderStatus
}

// ExpectOrderIDParam1 sets up expected param orderID for IOrderRepository.SetOrderStatus
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) ExpectOrderIDParam1(orderID models.OID) *mIOrderRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &IOrderRepositoryMockSetOrderStatusExpectation{}
	}

	if mmSetOrderStatus.defaultExpectation.params != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Expect")
	}

	if mmSetOrderStatus.defaultExpectation.paramPtrs == nil {
		mmSetOrderStatus.defaultExpectation.paramPtrs = &IOrderRepositoryMockSetOrderStatusParamPtrs{}
	}
	mmSetOrderStatus.defaultExpectation.paramPtrs.orderID = &orderID
	mmSetOrderStatus.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmSetOrderStatus
}

// ExpectStatusParam2 sets up expected param status for IOrderRepository.SetOrderStatus
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) ExpectStatusParam2(status models.OrderStatus) *mIOrderRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &IOrderRepositoryMockSetOrderStatusExpectation{}
	}

	if mmSetOrderStatus.defaultExpectation.params != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Expect")
	}

	if mmSetOrderStatus.defaultExpectation.paramPtrs == nil {
		mmSetOrderStatus.defaultExpectation.paramPtrs = &IOrderRepositoryMockSetOrderStatusParamPtrs{}
	}
	mmSetOrderStatus.defaultExpectation.paramPtrs.status = &status
	mmSetOrderStatus.defaultExpectation.expectationOrigins.originStatus = minimock.CallerInfo(1)

	return mmSetOrderStatus
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepository.SetOrderStatus
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Inspect(f func(orderID models.OID, status models.OrderStatus)) *mIOrderRepositoryMockSetOrderStatus {
	if mmSetOrderStatus.mock.inspectFuncSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("Inspect function is already set for IOrderRepositoryMock.SetOrderStatus")
	}

	mmSetOrderStatus.mock.inspectFuncSetOrderStatus = f

	return mmSetOrderStatus
}

// Return sets up results that will be returned by IOrderRepository.SetOrderStatus
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Return(err error) *IOrderRepositoryMock {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	if mmSetOrderStatus.defaultExpectation == nil {
		mmSetOrderStatus.defaultExpectation = &IOrderRepositoryMockSetOrderStatusExpectation{mock: mmSetOrderStatus.mock}
	}
	mmSetOrderStatus.defaultExpectation.results = &IOrderRepositoryMockSetOrderStatusResults{err}
	mmSetOrderStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOrderStatus.mock
}

// Set uses given function f to mock the IOrderRepository.SetOrderStatus method
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Set(f func(orderID models.OID, status models.OrderStatus) (err error)) *IOrderRepositoryMock {
	if mmSetOrderStatus.defaultExpectation != nil {
		mmSetOrderStatus.mock.t.Fatalf("Default expectation is already set for the IOrderRepository.SetOrderStatus method")
	}

	if len(mmSetOrderStatus.expectations) > 0 {
		mmSetOrderStatus.mock.t.Fatalf("Some expectations are already set for the IOrderRepository.SetOrderStatus method")
	}

	mmSetOrderStatus.mock.funcSetOrderStatus = f
	mmSetOrderStatus.mock.funcSetOrderStatusOrigin = minimock.CallerInfo(1)
	return mmSetOrderStatus.mock
}

// When sets expectation for the IOrderRepository.SetOrderStatus which will trigger the result defined by the following
// Then helper
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) When(orderID models.OID, status models.OrderStatus) *IOrderRepositoryMockSetOrderStatusExpectation {
	if mmSetOrderStatus.mock.funcSetOrderStatus != nil {
		mmSetOrderStatus.mock.t.Fatalf("IOrderRepositoryMock.SetOrderStatus mock is already set by Set")
	}

	expectation := &IOrderRepositoryMockSetOrderStatusExpectation{
		mock:               mmSetOrderStatus.mock,
		params:             &IOrderRepositoryMockSetOrderStatusParams{orderID, status},
		expectationOrigins: IOrderRepositoryMockSetOrderStatusExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOrderStatus.expectations = append(mmSetOrderStatus.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepository.SetOrderStatus return parameters for the expectation previously defined by the When method
func (e *IOrderRepositoryMockSetOrderStatusExpectation) Then(err error) *IOrderRepositoryMock {
	e.results = &IOrderRepositoryMockSetOrderStatusResults{err}
	return e.mock
}

// Times sets number of times IOrderRepository.SetOrderStatus should be invoked
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Times(n uint64) *mIOrderRepositoryMockSetOrderStatus {
	if n == 0 {
		mmSetOrderStatus.mock.t.Fatalf("Times of IOrderRepositoryMock.SetOrderStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOrderStatus.expectedInvocations, n)
	mmSetOrderStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOrderStatus
}

func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) invocationsDone() bool {
	if len(mmSetOrderStatus.expectations) == 0 && mmSetOrderStatus.defaultExpectation == nil && mmSetOrderStatus.mock.funcSetOrderStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOrderStatus.mock.afterSetOrderStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOrderStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOrderStatus implements mm_service.IOrderRepository
func (mmSetOrderStatus *IOrderRepositoryMock) SetOrderStatus(orderID models.OID, status models.OrderStatus) (err error) {
	mm_atomic.AddUint64(&mmSetOrderStatus.beforeSetOrderStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOrderStatus.afterSetOrderStatusCounter, 1)

	mmSetOrderStatus.t.Helper()

	if mmSetOrderStatus.inspectFuncSetOrderStatus != nil {
		mmSetOrderStatus.inspectFuncSetOrderStatus(orderID, status)
	}

	mm_params := IOrderRepositoryMockSetOrderStatusParams{orderID, status}

	// Record call args
	mmSetOrderStatus.SetOrderStatusMock.mutex.Lock()
	mmSetOrderStatus.SetOrderStatusMock.callArgs = append(mmSetOrderStatus.SetOrderStatusMock.callArgs, &mm_params)
	mmSetOrderStatus.SetOrderStatusMock.mutex.Unlock()

	for _, e := range mmSetOrderStatus.SetOrderStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOrderStatus.SetOrderStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.paramPtrs

		mm_got := IOrderRepositoryMockSetOrderStatusParams{orderID, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmSetOrderStatus.t.Errorf("IOrderRepositoryMock.SetOrderStatus got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetOrderStatus.t.Errorf("IOrderRepositoryMock.SetOrderStatus got unexpected parameter status, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.expectationOrigins.originStatus, *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOrderStatus.t.Errorf("IOrderRepositoryMock.SetOrderStatus got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOrderStatus.SetOrderStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOrderStatus.t.Fatal("No results are set for the IOrderRepositoryMock.SetOrderStatus")
		}
		return (*mm_results).err
	}
	if mmSetOrderStatus.funcSetOrderStatus != nil {
		return mmSetOrderStatus.funcSetOrderStatus(orderID, status)
	}
	mmSetOrderStatus.t.Fatalf("Unexpected call to IOrderRepositoryMock.SetOrderStatus. %v %v", orderID, status)
	return
}

// SetOrderStatusAfterCounter returns a count of finished IOrderRepositoryMock.SetOrderStatus invocations
func (mmSetOrderStatus *IOrderRepositoryMock) SetOrderStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderStatus.afterSetOrderStatusCounter)
}

// SetOrderStatusBeforeCounter returns a count of IOrderRepositoryMock.SetOrderStatus invocations
func (mmSetOrderStatus *IOrderRepositoryMock) SetOrderStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrderStatus.beforeSetOrderStatusCounter)
}

// Calls returns a list of arguments used in each call to IOrderRepositoryMock.SetOrderStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOrderStatus *mIOrderRepositoryMockSetOrderStatus) Calls() []*IOrderRepositoryMockSetOrderStatusParams {
	mmSetOrderStatus.mutex.RLock()

	argCopy := make([]*IOrderRepositoryMockSetOrderStatusParams, len(mmSetOrderStatus.callArgs))
	copy(argCopy, mmSetOrderStatus.callArgs)

	mmSetOrderStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetOrderStatusDone returns true if the count of the SetOrderStatus invocations corresponds
// the number of defined expectations
func (m *IOrderRepositoryMock) MinimockSetOrderStatusDone() bool {
	if m.SetOrderStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOrderStatusMock.invocationsDone()
}

// MinimockSetOrderStatusInspect logs each unmet expectation
func (m *IOrderRepositoryMock) MinimockSetOrderStatusInspect() {
	for _, e := range m.SetOrderStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOrderRepositoryMock.SetOrderStatus at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOrderStatusCounter := mm_atomic.LoadUint64(&m.afterSetOrderStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOrderStatusMock.defaultExpectation != nil && afterSetOrderStatusCounter < 1 {
		if m.SetOrderStatusMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to IOrderRepositoryMock.SetOrderStatus at\n%s", m.SetOrderStatusMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to IOrderRepositoryMock.SetOrderStatus at\n%s with params: %#v", m.SetOrderStatusMock.defaultExpectation.expectationOrigins.origin, *m.SetOrderStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOrderStatus != nil && afterSetOrderStatusCounter < 1 {
		m.t.Errorf("Expected call to IOrderRepositoryMock.SetOrderStatus at\n%s", m.funcSetOrderStatusOrigin)
	}

	if !m.SetOrderStatusMock.invocationsDone() && afterSetOrderStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to IOrderRepositoryMock.SetOrderStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOrderStatusMock.expectedInvocations), m.SetOrderStatusMock.expectedInvocationsOrigin, afterSetOrderStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockGetByOrderIDInspect()

			m.MinimockSetOrderStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetByOrderIDDone() &&
		m.MinimockSetOrderStatusDone()
}
